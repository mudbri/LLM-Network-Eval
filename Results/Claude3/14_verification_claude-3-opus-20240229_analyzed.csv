Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence,QD - Goal clear?(0/1),QD - Context clear?(0/1),QD - How challenging(1-4),QD - Level learnt(1-7),SM - Description,SM - Goal understood?(0/1),SM - Context understood?(0/1),SM - Implied Context understood?(0/1),SM - Relvant facts identified?(0/1),SM - Correct facts retieved?(0/1),SM - No incorrect facts?(0/1),SM - Correct reasoning?(0/1),SM - Misunderstanding General,SM - Misunderstanding Reasons,SM - Misunderstanding General (secondary),SM - Misunderstanding Reasons (secondary),AQ - Inferrable(0-2)?,Source links work(number),Sources Types,Sources Relevant(number),Source Problems,AQ - Precise?,AQ - Explainable?,Effect - Description of effects,Effect - Conceptual error in explanaiton?(0/1),Effect - Subtopics,Effect - Error Type,Effect - Severity,Effect - Who is most effected(1-4),CD - detection student(1-3),CD - correction student(1-8),CD - detection knowledgeable(1-3),CD - correction knowledgeable(1-8),Score-right-minus-wrong
106,Which of the following are true about configuration verification? Select all that apply.,"a. Configuration verification can only detect errors after the configuration is installed on production routers.
b. Configuration verification cannot detect incorrect protocol behavior that may result from faulty hardware.
c. Verifying the correctness of network behavior based on configuration requires a model of protocol behavior.
d. Configuration verification requires a large-scale simulation of network protocols, complete with tests for different message orderings and timings.
e. Configuration verification cannot detect incorrect protocol behavior that may result from buggy software.
",,"b,c,e",c,,"Configuration verification requires a model of the expected protocol behavior in order to check if the configuration will produce the desired network behavior. It does not necessarily require large-scale simulations with tests for message orderings and timings (d). Configuration verification can be done before installing configurations on production routers (a). While it may not catch all issues caused by faulty hardware (b) or buggy software (e), configuration verification is still a useful step to validate intended behavior based on the configuration itself.","['https://www.cs.princeton.edu/~jrex/papers/veriflow13.pdf', 'https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final68.pdf']",0,14_verification,0.9,1,1,1,2,5,Config verification cannot verify faulty hardware and faulty software,1,1,1,1,1,1,0,Incorrect reasoning/deduction,Self-aware but still wrong conclusion,,,1,1,research paper,0,,1,1,"Not know that config verification cannot verify software and hardware bugs. We have to verify them separately (although there are new papers to verify software and hardware bugs, they are not called configuration verification)",0,Configuration Verification,misinformation,Minor,1,1,4,1,1,0.1999999999999999
107,"Which of the following assertions could be verified with configuration verification (i.e., of a snapshot of router and switch configuration)? Select all that apply.","a. A route learned from one peer will not be readvertised to another peer.
b. The current settings of link weights will result in all routers being connected.
c. The configuration of route reflectors and clients ensures that any route learned from a neighboring AS will propagate to all routers in the topology.
d. There is no traffic pattern that would ever result in a stateful firewall dropping traffic.
e. Any time that an infection occurs, hosts are automatically quarantined.
",,"a,b,c","a,c",,"Configuration verification can check properties that depend only on the configuration, not on dynamic network state. Option (a) can be verified by checking that route filters are correctly configured to prevent readvertisement between peers. Option (c) can be verified by analyzing the route reflector configuration to ensure routes propagate fully. Options (b), (d) and (e) depend on dynamic state like link weights, traffic patterns, and infection events, so they cannot be verified solely from configuration.","['https://www.cs.princeton.edu/~jrex/papers/sigcomm13.pdf', 'https://www.usenix.org/conference/nsdi20/presentation/abhashkumar']",0,14_verification,0.9,1,1,1,1,5,Does not know that the current settings are affecting link connectivity is not a dynamic property,1,1,1,1,0,1,1,Wrong Facts/Concept,Incorrect information/concept,,,0,1,research paper,1,,1,1,Not know that config verification can verify connectivity,1,Configuration Verification,"misinformation, debugging delay",Minor,1,3,4,2,2,0.6000000000000001
108,Which of the following are true about data-plane verification? Select all that apply.,"a. Data-plane verification techniques such as header-space analysis typically operate on a single ""snapshot"" of data-plane state.
b. Data plane verification can only operate on the forwarding table of a single router or switch; network-wide analysis is not possible.
c. Data-plane verification may detect errors that configuration analysis can miss in the cases of buggy control-plane software.
d. Data-plane verification requires accurate modeling of network protocols, including which bits are present in which part of the packet header.
e. Header-space analysis can only provide verification/analysis for specific packets; it cannot answer questions for general parts of flowspace.
",,"a,c","a,c,d",,"Data-plane verification techniques like header-space analysis typically operate on a snapshot of the data-plane state across the network (a). It can detect errors missed by configuration analysis if there are bugs in the control-plane software that cause the data plane to behave differently than intended (c). Data-plane verification requires accurately modeling the network protocols and header fields to reason about packet processing (d). However, data-plane verification is not limited to a single device and can perform network-wide analysis (b is incorrect). Header-space analysis can reason about general parts of the flow space, not just specific packets (e is incorrect).","['https://www.cs.princeton.edu/~jrex/papers/veriflow13.pdf', 'https://www.usenix.org/system/files/conference/nsdi17/nsdi17-horn.pdf', 'https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final8.pdf']",0,14_verification,0.95,1,1,1,1,5,Conceptual issue - data plane verification does not require knowledge about protocols,1,1,1,1,0,1,1,Wrong Facts/Concept,Incorrect information/concept,,,0,1,research paper,1,,1,1,Not understanding dataplane verification,1,Data Plane Verification,"misinformation, debugging delay",Minor,1,3,4,2,2,0.6000000000000001
109,Which of the following assertions could be verified with data plane verification? Select all that apply.,"a. The network will remain connected, given the failure of at most two links.
b. Two virtual network ""slices"" are not completely isolated: it is possible for traffic to travel from one slice to the other.
c. The configuration of the network's routing protocols will result in persistent oscillation (i.e., they will never settle on a stable set of routes).
d. The forwarding table state in the routers across the network will result in a forwarding loop.
e. The rules installed on the firewalls in the network ensure that only port 80 traffic can ever reach the web server from the rest of the Internet.",,"b,d,e","b,d,e",,"Data plane verification focuses on the actual forwarding behavior of the network based on the forwarding tables and configurations on devices like routers and firewalls. It can verify properties like isolation between virtual networks (b), absence of forwarding loops (d), and enforcement of traffic filtering rules (e). In contrast, verifying network connectivity under link failures (a) or convergence of routing protocols (c) would fall under the scope of control plane verification, as they relate to the routing protocols and topology rather than the data plane forwarding.","['https://www.cs.princeton.edu/~jrex/papers/veriflow13.pdf', 'https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final127.pdf', 'https://www.cs.cornell.edu/~jnfoster/papers/frenetic-icfp11.pdf']",1,14_verification,0.9,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1
110,Which of the following is true about Kinetic policies? Select all that apply.,"a. State transitions can be exogenous or endogenous.
b. Kinetic's NuSMV verifier can verify that the data plane will never have loops.
c. State transitions can occur based on timing (e.g., a timeout).
d. The Kinetic controller can only process external events from routers and switches.
e. Pyretic's composition operators can help prevent state explosion.
",,"a,c,e","a,c,e",,"Kinetic policies can have both exogenous state transitions, which are triggered by external events like packets or messages, and endogenous transitions, which occur based on internal timers or counters (choices a and c are correct). Pyretic's composition operators like parallel and sequential composition can help manage the complexity of Kinetic policies and prevent state explosion (choice e is correct). However, Kinetic's NuSMV verifier checks for properties like forwarding loops and black holes, but cannot guarantee the complete absence of loops in all cases (choice b is incorrect). The Kinetic controller can process external events beyond just those from routers and switches, such as from middleboxes or other controllers (choice d is incorrect).","['Kinetic: Verifiable Dynamic Network Control, ACM SIGCOMM, 2015', 'https://kinetic.noise.gatech.edu/', 'Modular SDN Programming with Pyretic, USENIX ;login, 2013']",1,14_verification,0.9,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1
112,"Which of the following NuSMV expressions encodes the statement ""It is always possible for the policy state to go to 'allow'.""","a. SPEC AG (!authenticated -> AX policy=allow)
b. None of the above.
c. SPEC A [ policy=allow U authenticated ]
d. SPEC AG (authenticated -> AX policy=allow)
e. SPEC AG (EF policy=allow)
",,e,e,,"The given statement ""It is always possible for the policy state to go to 'allow'"" is best encoded by the NuSMV expression 'SPEC AG (EF policy=allow)'. This uses the CTL (Computation Tree Logic) operators: - AG: ""always globally"" or ""for all paths, for all states"" - EF: ""exists finally"" or ""there exists a path where the condition eventually holds""  So this expression states that for all paths, for all states, there exists a path where the policy eventually becomes 'allow'. This matches the original statement that it is always possible to reach the 'allow' policy state.  The other options are incorrect: - (a) and (d) only allow transitioning to 'allow' when authenticated, which is more restrictive than the original statement.  - (c) uses the 'until' operator in a way that doesn't match the meaning of the original statement. - (b) is not the correct answer since (e) does encode the statement.","['NuSMV 2.6 User Manual: https://nusmv.fbk.eu/NuSMV/userman/v26/nusmv.pdf', 'Computation Tree Logic: https://en.wikipedia.org/wiki/Computation_tree_logic']",1,14_verification,0.95,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1
