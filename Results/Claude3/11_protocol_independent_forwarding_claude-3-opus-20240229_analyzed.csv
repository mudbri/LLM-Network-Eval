Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence,QD - Goal clear?(0/1),QD - Context clear?(0/1),QD - How challenging(1-4),QD - Level learnt(1-7),SM - Description,SM - Goal understood?(0/1),SM - Context understood?(0/1),SM - Implied Context understood?(0/1),SM - Relvant facts identified?(0/1),SM - Correct facts retieved?(0/1),SM - No incorrect facts?(0/1),SM - Correct reasoning?(0/1),SM - Misunderstanding General,SM - Misunderstanding Reasons,SM - Misunderstanding General (secondary),SM - Misunderstanding Reasons (secondary),AQ - Inferrable(0-2)?,Source links work(number),Sources Types,Sources Relevant(number),Source Problems,AQ - Precise?,AQ - Explainable?,Effect - Description of effects,Effect - Conceptual error in explanaiton?(0/1),Effect - Subtopics,Effect - Error Type,Effect - Severity,Effect - Who is most effected(1-4),CD - detection student(1-3),CD - correction student(1-8),CD - detection knowledgeable(1-3),CD - correction knowledgeable(1-8),Score-right-minus-wrong
78,What are some of the desired features in future SDN switches that motivate a programmable data plane? Select all that apply.,"a. Reducing energy consumption for custom packet processing.
b. Processing packets at higher rates.
c. A wider range of packet processing primitives.
d. Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel.
e. A configurable packet parser that is not tied to a specific header format.
",,"c,d,e","b,c,d,e",,"Some of the desired features in future SDN switches that motivate a programmable data plane include:b) Processing packets at higher rates to handle increasing network speeds and traffic volumes.  c) Supporting a wider range of packet processing primitives beyond basic forwarding to enable more advanced network functions.d) Providing flexible match-action tables that can be composed in various ways to implement custom packet processing pipelines.e) Having a configurable packet parser not tied to specific header formats, allowing parsing of custom or future protocols.Reducing energy consumption (a) is a general goal but not a key motivator for programmable data planes specifically.","[""Nick McKeown et al. 'OpenFlow: Enabling Innovation in Campus Networks', ACM SIGCOMM CCR, 2008"", ""Pat Bosshart et al. 'P4: Programming Protocol-Independent Packet Processors', ACM SIGCOMM CCR, 2014"", ""Nate Foster et al. 'Languages for Software-Defined Networks', IEEE Communications Magazine, 2013""]",0,11_protocol_independent_forwarding,0.95,1,1,1,2,3,Conceptual issue - programmable data planes do not intend to process packets at a higher rate,1,1,1,1,0,1,1,Wrong Facts/Concept,Incorrect information/concept,,,0,3,"research paper, research paper, research paper",3,,1,1,Not much,1,Protocol Independent Forwarding,misinformation,Minor,1,3,4,1,1,0.6000000000000001
79,Which of the following best describes protocol independence?,"a. The ability to configure a packet parser in hardware that is agnostic to (and not constrained by) the control protocol.
b. The ability to evolve an existing control protocol without breaking interoperability.
c. The ability to run a switch independently from the controller.
d. The ability to support multiple protocols running in parallel on the same hardware.
e. The ability to run a network with both legacy OpenFlow switches and switches that support custom packet processing.
",,a,a,,"Protocol independence in the context of software-defined networking refers to the ability to configure packet parsing and processing in the data plane hardware that is not tied to or constrained by the specific control protocol being used. This allows the data plane to handle packets flexibly based on the defined forwarding rules, regardless of what control protocol (like OpenFlow) is used to program those rules from the control plane. The other options, while related to aspects of SDN, do not directly define protocol independence.","['https://www.opennetworking.org/sdn-definition/', 'https://www.sdxcentral.com/networking/sdn/definitions/what-is-protocol-independence/']",1,11_protocol_independent_forwarding,0.9,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1
81,Which of the following describe functions of the P4 parser? Select all that apply.,"a. Constructing a graph of dependencies between different logical tables.
b. Translating rules to physical tables.
c. Verifying that the description of packet parsing is consistent with the behavior of an existing hardware switch (e.g., a legacy OpenFlow switch).
d. Translating a packet processing specification to a state machine.
e. Mapping logical tables to underlying switch resources.
",,"c,d",d,,The P4 parser is responsible for translating a packet processing specification written in the P4 language into a state machine that describes how packets should be parsed and processed. It takes the declarative P4 program and generates the logic for a programmable parser to extract the desired header fields from incoming packets based on the specified protocol headers and their ordering.,"['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html#sec-parsing', 'https://opennetworking.org/wp-content/uploads/2020/12/P4_Tutorial.pdf']",0,11_protocol_independent_forwarding,0.9,1,1,1,1,5,Misinformation about the purpose and jobs of the parser,1,1,1,1,0,1,1,Wrong Facts/Concept,Incorrect information/concept,,,0,1,documentation,1,,1,1,Misunderstanding parser,0,P4,misinformation,Minor,1,3,3,3,3,0.6000000000000001
82,"Which of the following best describe the relationship between a language like P4, an assembler like NetASM, and target programmable hardware (e.g., RMT)?","a. P4 is much more amenable to ""cost semantics"" (i.e., figuring out how much a particular operation would cost in terms of power or area) than NetASM.
NetASM and P4 are two examples of high-level programming languages; they are interchangeable.
b. P4 has verifiable semantics, whereas NetASM does not.
c. A language like P4 would ""compile"" to an assembly language like NetASM, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
d. A language like NetASM would ""compile"" to an assembly language like P4, which would then specify a one-to-one relationship with resources on the target forwarding hardware.",,c,c,,"P4 is a high-level programming language used to specify packet processing behavior in software-defined networks. It provides an abstraction layer that allows network programmers to define how packets should be processed without worrying about the underlying hardware details. On the other hand, NetASM is a low-level assembly language that provides a more direct mapping to the hardware resources of the target forwarding device. In a typical workflow, P4 code would be compiled to NetASM, which would then be used to configure the hardware resources (e.g., match-action tables) of the target device such as RMT (Reconfigurable Match Tables). This compilation process allows the high-level P4 abstractions to be mapped to the specific capabilities of the hardware.","['The P4 Language Specification, Version 1.0.5, https://p4.org/p4-spec/docs/P4-16-v1.0.5.html', 'P4 NetASM: In-Network Assembly, https://dl.acm.org/doi/10.1145/3422604.3425938', 'RMT: Reconfigurable Match Tables for High Performance Packet Classification and Forwarding, https://yuba.stanford.edu/~nickm/papers/ancs_rmt.pdf']",1,11_protocol_independent_forwarding,0.9,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1
83,Which of the folloiwing instruction types create state elements in NetASM? Select all that apply.,"a. JMP
b. DRP
c. LBL
d. MKT
e. MKR
",,"d,e","d,e",,"In NetASM, the MKT (make tag) and MKR (make register) instructions are used to create state elements. MKT creates a tag, which is a stateful memory element that can be used for matching packet fields. MKR creates a register, which is a stateful memory element that can store and update values. The other instructions - JMP (jump), DRP (drop packet), and LBL (label) - do not create any state elements.","['NetASM: A Low-level Assembly Language for Packet Processing on Programmable Routers, Shahbaz et al., SIGCOMM 2019', 'https://github.com/NetASM/NetASM-python/wiki/NetASM-Specification']",1,11_protocol_independent_forwarding,0.95,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1
84,Which of the following are true about locally contained applications? Select all that apply.,"a. Locally contained applications can be implemented with regular OpenFlow instructions.
b. A MAC learning switch can be implemented as a locally contained application.
c. Locally contained applications forward packets more slowly than their stateless counterparts.
d. A locally contained application can implement SDN logic without ever requiring a packet to be sent to the controller.
e. Locally contained applications allow the hardware pipeline to make switch-local state modifications.
",,"b,d,e","b,d,e",,Locally contained applications can implement certain SDN logic entirely within the switch hardware pipeline without requiring packets to be sent to the controller. A MAC learning switch is an example of a locally contained application since it can learn MAC addresses and make forwarding decisions based on local switch state. The hardware pipeline can make local state modifications to enable this. Locally contained applications do not necessarily forward packets more slowly and are not limited to just regular OpenFlow instructions.,"['https://opennetworking.org/wp-content/uploads/2013/02/TR_SDN_ARCH_1.0_06062014.pdf', 'https://www.opennetworking.org/images/stories/downloads/sdn-resources/technical-reports/TR_SDN-ARCH-Overview-1.1-11112014.02.pdf']",1,11_protocol_independent_forwarding,0.9,1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1
86,What are some examples of optimizations that a compiler could perform on NetASM instructions? Select all that apply.,"a. Preventing bufferbloat for real-time application traffic.
b. Forwarding packets for high-volume flows at higher rates.
c. Composing or decomposing tables to save either on table size or table width.
d. Only instantiating hardware resources (e.g., table entries) for flows that actually have nonzero traffic volume.
e. Reordering instructions so that subsequent tables need not be as large (e.g., not storing state for unmatched packets).
",,"c,d,e","c,e",,"A compiler for NetASM instructions could perform optimizations such as composing or decomposing tables to save on table size or width (c), and reordering instructions so that subsequent tables need not be as large, for example by not storing state for unmatched packets (e). The other options are not compiler optimizations but rather runtime optimizations or features.","['NetASM: A Low-Level Assembly Language for Packet Processing on Programmable Hardware, Sivaraman et al., SIGCOMM 2020', 'Compiling Packet Programs to Reconfigurable Switches, Gao et al., NSDI 2015']",0,11_protocol_independent_forwarding,0.8,1,1,1,1,5,Misinformation about the what the compiler can do in NetASM,1,1,1,1,0,1,1,Wrong Facts/Concept,Incorrect information/concept,,,0,1,research paper,1,,1,0,Misunderstanding compiler in NetASM,1,NetASM,misinformation,MInor,1,3,4,3,4,0.6000000000000001
