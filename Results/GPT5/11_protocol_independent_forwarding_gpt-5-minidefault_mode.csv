Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
78,What are some of the desired features in future SDN switches that motivate a programmable data plane? Select all that apply.,"a. Reducing energy consumption for custom packet processing.
b. Processing packets at higher rates.
c. A wider range of packet processing primitives.
d. Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel.
e. A configurable packet parser that is not tied to a specific header format.
",,"c,d,e","b,c,d,e",,"Programmable data planes are motivated by the need to process packets at high rates (b), support a wider set of packet-processing primitives (c), provide flexible match-action table composition and pipelines (d), and allow configurable, protocol-independent packet parsing (e). Reducing energy consumption for custom packet processing (a) is not a primary, widely-cited motivation for programmable data planes (the goals focus on flexibility, extensibility, and performance rather than energy optimization).","['https://p4.org/', 'https://dl.acm.org/doi/10.1145/2643634.2643650 (P4: Programming Protocol-Independent Packet Processors)', 'https://p4.org/papers/ (P4/PISA and related programmable data plane papers)']",0,11_protocol_independent_forwarding,0.9,1
79,Which of the following best describes protocol independence?,"a. The ability to configure a packet parser in hardware that is agnostic to (and not constrained by) the control protocol.
b. The ability to evolve an existing control protocol without breaking interoperability.
c. The ability to run a switch independently from the controller.
d. The ability to support multiple protocols running in parallel on the same hardware.
e. The ability to run a network with both legacy OpenFlow switches and switches that support custom packet processing.
",,a,a,,"Protocol independence in SDN/P4 context means the data‑plane (packet parser and match‑action pipeline) is not hard‑wired to particular protocol headers or a fixed control protocol — i.e., you can configure the parser and processing logic in hardware to recognize and handle new or custom protocols. Options b–e describe other concerns (control‑protocol evolution, controller dependence, multi‑protocol coexistence, interoperability with legacy OpenFlow) but do not capture the core meaning of protocol independence.","['https://p4.org/', 'https://www.microsoft.com/en-us/research/publication/p4-programming-protocol-independent-packet-processors/', 'https://dl.acm.org/doi/10.1145/2620728.2620737']",1,11_protocol_independent_forwarding,0.95,1
81,Which of the following describe functions of the P4 parser? Select all that apply.,"a. Constructing a graph of dependencies between different logical tables.
b. Translating rules to physical tables.
c. Verifying that the description of packet parsing is consistent with the behavior of an existing hardware switch (e.g., a legacy OpenFlow switch).
d. Translating a packet processing specification to a state machine.
e. Mapping logical tables to underlying switch resources.
",,"c,d",d,,"The P4 parser is responsible for describing how to extract headers from packet bytes and expressing that description as a parse state machine (parse states and transitions). It does not perform mapping of logical tables to hardware resources, translate rules to physical tables, or construct dependency graphs between tables—those are tasks of the P4 compiler/back-end and control/management plane, nor does the parser itself verify consistency with existing hardware switches.","['https://p4.org/p4-spec/docs/P4-16-v1.2.0-spec.html#_parsers', 'https://p4.org/', 'https://conferences.sigcomm.org/sigcomm/2014/papers/p319-bosshart.pdf']",0,11_protocol_independent_forwarding,0.95,1
82,"Which of the following best describe the relationship between a language like P4, an assembler like NetASM, and target programmable hardware (e.g., RMT)?","a. P4 is much more amenable to ""cost semantics"" (i.e., figuring out how much a particular operation would cost in terms of power or area) than NetASM.
NetASM and P4 are two examples of high-level programming languages; they are interchangeable.
b. P4 has verifiable semantics, whereas NetASM does not.
c. A language like P4 would ""compile"" to an assembly language like NetASM, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
d. A language like NetASM would ""compile"" to an assembly language like P4, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
",,c,c,,"P4 is a high-level, target-independent language for programming packet-processing pipelines. NetASM is an assembly-like intermediate/abstract machine representation (an ISA) used as a lower-level target for compilers. Typical toolchains compile a P4 program down to an IR/assembly like NetASM, and then a backend maps NetASM instructions onto concrete resources (match-action stages, ALUs, memory) on a target architecture such as RMT/Tofino — i.e., NetASM is the layer that is made concrete with a one-to-one (or otherwise explicit) mapping to hardware resources. The other choices are incorrect (a: NetASM is lower-level and not “interchangeable” with P4; b: both have formal semantics work and neither statement is generally true as written; d: reverses the compile direction).","['https://p4.org/p4-spec/', 'https://conferences.sigcomm.org/sigcomm/2014/papers/p36-bosshart.pdf (Bosshart et al., ""P4: Programming Protocol-Independent Packet Processors"")', 'https://github.com/p4lang/netasm (NetASM project/repository)', 'https://www.barefootnetworks.com/technology/ (background on RMT/Tofino architectures and mapping P4 to hardware)']",1,11_protocol_independent_forwarding,0.82,1
83,Which of the folloiwing instruction types create state elements in NetASM? Select all that apply.,"a. JMP
b. DRP
c. LBL
d. MKT
e. MKR
",,"d,e","d,e",,MKT and MKR are the NetASM instructions used to create state elements: MKT (make table) creates a table (stateful match/action table) and MKR (make register) creates a register (state element). JMP and LBL are control-flow constructs and DRP is the drop operation — none of these allocate persistent state.,"['https://github.com/NetASM/netasm (NetASM specification/repository)', 'NetASM paper / specification (NetASM: a portable intermediate representation for programmable data planes) — available via arXiv / conference proceedings']",1,11_protocol_independent_forwarding,0.75,1
84,Which of the following are true about locally contained applications? Select all that apply.,"a. Locally contained applications can be implemented with regular OpenFlow instructions.
b. A MAC learning switch can be implemented as a locally contained application.
c. Locally contained applications forward packets more slowly than their stateless counterparts.
d. A locally contained application can implement SDN logic without ever requiring a packet to be sent to the controller.
e. Locally contained applications allow the hardware pipeline to make switch-local state modifications.
",,"b,d,e","b,d,e",,"Locally-contained applications run entirely on the switch data plane and therefore can implement stateful SDN logic (e.g., MAC learning) without involving the controller (d, b). They rely on switch-local state modifications in the hardware pipeline (e), which is the defining capability that differentiates them from purely stateless match-action rules. They are not generally realizable using only “regular” (stateless) OpenFlow instructions (a is false) because those instructions do not provide the necessary built-in switch-local state update primitives; and there is no general rule that locally-contained apps forward more slowly than stateless ones—such apps are intended to run at line rate in the data plane, so (c) is false.","['https://opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.3.0.pdf', 'https://arxiv.org/abs/1406.0440 (Kreutz et al., ""Software-Defined Networking: A Comprehensive Survey"")', 'https://dl.acm.org/doi/10.1145/2695948.2695964 (Cascone et al., ""OpenState: Programming Platform-Independent Stateful OpenFlow Applications Inside the Switch"")']",1,11_protocol_independent_forwarding,0.9,1
86,What are some examples of optimizations that a compiler could perform on NetASM instructions? Select all that apply.,"a. Preventing bufferbloat for real-time application traffic.
b. Forwarding packets for high-volume flows at higher rates.
c. Composing or decomposing tables to save either on table size or table width.
d. Only instantiating hardware resources (e.g., table entries) for flows that actually have nonzero traffic volume.
e. Reordering instructions so that subsequent tables need not be as large (e.g., not storing state for unmatched packets).
",,"c,d,e","c,d,e",,"c, d and e are realistic compiler optimizations for a NetASM-like intermediate representation: compilers can compose/decompose logical match-action tables to trade off table width vs. number of tables (saving hardware resources), instantiate hardware resources lazily only for flows that actually carry traffic (avoiding wasting TCAM/hash slots), and reorder/schedule instructions and table lookups so later tables need less state (e.g., avoid allocating state for packets that will be filtered earlier). Options a and b describe run-time traffic management/QoS behaviors (buffer management or per‑flow rate scheduling) rather than static compile-time transformations of NetASM instruction sequences and table/resource mapping, so they are not compiler optimizations in this context.","['https://p4.org/p4-spec/docs/P4-16-v1.2.0.html', 'https://dl.acm.org/doi/10.1145/2656877.2656890 (Bosshart et al., P4 SIGCOMM paper describing programmable data planes and compilation concerns)', 'https://www.microsoft.com/en-us/research/publication/domino-programmable-packet-processing/ (Domino paper: examples of compiler optimizations for packet-processing pipelines)']",1,11_protocol_independent_forwarding,0.9,1
