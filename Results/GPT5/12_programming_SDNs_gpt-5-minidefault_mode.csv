Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
87,Which of the following reasons make programming OpenFlow switches difficult? Select all that apply.,"a. An OpenFlow controller only sees events for packets that the switches do not know how to handle.
b. OpenFlow networks require a single, centralized network controller.
c. Networks often have switches from multiple hardware vendors.
d. OpenFlow switches control switches at a low level of abstraction.
e. Network policies involve many independent tasks that may have conflicting behaviors.
",,"a,d,e","a,c,d,e",,"a: True — an OpenFlow controller typically only receives packet-in events for packets that miss the switch’s flow tables, so the controller has limited visibility and must programmatically handle misses/reactive events (makes correct, global behavior harder).

c: True — switches from multiple hardware vendors differ in supported match fields, actions, table pipeline semantics and performance; heterogeneity forces controller/app code to handle capabilities and inconsistencies.

d: True — OpenFlow exposes low-level match/action and flow-table primitives (rather than high-level intents); programming at that low level is tedious and error-prone, motivating higher-level abstractions.

e: True — network policies are composed of many independent tasks (ACLs, routing, QoS, monitoring, etc.) that can interact or conflict; composing and resolving such conflicts is a major programming challenge.

b: False — OpenFlow/SDN architectures can (and often do) use distributed or multiple controllers; requiring a single centralized controller is not an inherent reason that makes OpenFlow programming difficult.","['https://www.sigcomm.org/sites/default/files/ccr/papers/2008/July/1642781.1642790.pdf (McKeown et al., OpenFlow SIGCOMM 2008)', 'https://opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.3.0.pdf (OpenFlow Switch Specification)', 'https://arxiv.org/abs/1406.0440 (Kreutz et al., ""Software-Defined Networking: A Comprehensive Survey"")', 'https://www.cs.cornell.edu/~foster/papers/frenetic.pdf (Frenetic / high-level SDN programming languages — motivation for higher-level abstractions and policy composition)']",0,12_programming_SDNs,0.9,1
89,"Suppose that a network operator wants to express a policy that drops all traffic except for traffic from a specific IP prefix (i.e., group of IP addresses).  What problems exist with expressing this policy as a set of OpenFlow rules? Select all that apply.","a. Switches have limited room for flow table entries and cannot store rules for all IP addresses in a prefix by default.
b. The controller may see more than the first packet for a flow that it has already installed.
c. If the controller installs the rules in the wrong order, all traffic might be dropped, instead of allowing the permitted traffic.
d. If the operator starts adding more IP addresses that are permitted to send traffic, performance of the switch might suffer as the number of entries in the switch table grows.
e. Flow table entries can only perform exact matches on IP addresses, so installing rules that operate on groups of IP addresses will take many flow-table entries in the switch.
",,"a,b,c,d","a,c,d",,"a) True — hardware switches have limited flow-table (TCAM) capacity; representing a large prefix by expanding to per-address rules can exceed table space. c) True — OpenFlow rule matching uses priorities; installing a catch‑all drop with a higher priority (or installing rules in the wrong order with incorrect priorities) can cause the allowed-prefix rule to be shadowed and permitted traffic to be dropped. d) True — as the operator adds more permitted IPs, the number of flow entries grows and can hurt switch performance (more TCAM usage, longer lookup/management overhead). 

b) False/irrelevant — normally a reactive controller sees the first packet of a flow and then the switch handles subsequent packets once a flow entry is installed; seeing additional packets is typically due to timeouts/misconfiguration, not an inherent problem of expressing a drop‑all/allow‑prefix policy. e) False — OpenFlow supports masked/prefix matches on IP fields (not only exact matches), so you do not always need one entry per IP to match a prefix.","['https://opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.3.0.pdf', 'https://opennetworking.org/wp-content/uploads/2013/04/SDN_White_Paper_Jan_2012.pdf', 'https://arxiv.org/abs/1406.0440', 'http://www.cs.cmu.edu/~dga/papers/devoflow-nsdi12.pdf']",0,12_programming_SDNs,0.85,1
90,Which of the following have examples of sequential composition? Select all that apply.,"a. Block all port 80 traffic and count the number of packets that are blocked.
b. Load balance traffic based on whether the traffic matches a particular destination IP prefix.
c. Block all traffic except port 80 and count the number of packets that are blocked.
d. Block all traffic except port 80 traffic, and load balance port 80 traffic across three destination IP addresses.
e. Block all traffic except port 80 and count the number of packets that are not blocked.
",,"b,d,e","a,c,d,e",,"Sequential composition means applying one policy and then another (the output of the first is input to the second). 
- a: block port 80, then count the packets blocked — clearly two steps (filter then counter). 
- c: block all except port 80 (filter), then count the blocked packets — filter followed by a counter. 
- d: filter (block non‑port‑80) then apply a load‑balancer to the remaining (port‑80) traffic — two policies applied in sequence. 
- e: filter (block non‑port‑80) then count the packets that remain (not blocked) — also filter then counter. 
- b is not sequential composition: it describes a single conditional/load‑balancing decision based on a match (a single policy with branching), not an explicit sequence of two separate policies.","['https://www.cs.princeton.edu/~jre/papers/netkat-popl15.pdf (NetKAT: Semantic foundations for networks)', 'https://www.opennetworking.org/wp-content/uploads/2013/04/openflow-switch-v1.3.1.pdf (OpenFlow 1.3.1 specification — pipeline and actions)']",0,12_programming_SDNs,0.95,1
91,Which of the following have examples of parallel composition? Select all that apply.,"a. Perform load balancing on any traffic that arrives from prefix 130.207.0.0/16 or is destined to port 80.
b. Perform MAC learning on all traffic that is not blocked by a firewall rule.
c. Count all port 80 traffic.
d. Block all traffic whose source IP address is contained in a list of blocked IP addresses.
e. Load balance traffic across multiple destination IP addresses and perform routing to the resulting destination IP addresses.
",,"a,c,d","a,e",,"Parallel composition corresponds to applying two (or more) independent policies and taking the union of their effects. (a) is naturally a parallel/union of two match+action policies: (match src 130.207.0.0/16; load-balance) + (match dst port 80; load-balance). (e) also exhibits parallel composition: a load‑balancer typically branches packets to multiple destination IPs in parallel (one branch per destination); routing is then applied to each resulting branch (so the load‑balancer is a parallel composition of per-destination branches, possibly followed sequentially by routing). The other choices describe single policies or sequential composition (e.g., firewall then MAC learning) rather than examples of parallel composition.","['https://cs.stanford.edu/people/kao/netkat/netkat.pdf (NetKAT: semantic foundations for network programming)', 'https://www.usenix.org/legacy/event/nsdi11/tech/full_papers/foster/foster_html/index.html (Frenetic: a network programming language)']",0,12_programming_SDNs,0.9,1
92,Which of the following is the appropriate Pyretic rule for matching traffic that sends packets from either 10.0.0.1 or 10.0.0.2 to IP address 1.2.3.4?,"a. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
b. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
c. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
d. (match(srcip=10.0.0.1) >> (match(srcip=10.0.0.2) >> mod(dstip=1.2.3.4))
e. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
",,c,c,,"In Pyretic '+' composes policies in parallel (logical OR of match predicates), while '>>' composes sequentially (apply the second policy to packets selected by the first). To select packets whose srcip is either 10.0.0.1 or 10.0.0.2 and then rewrite their destination, you first OR the two source matches and then sequentially apply mod(dstip=1.2.3.4). That is (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4).","['https://github.com/frenetic-lang/pyretic/blob/master/doc/users-guide.md', 'https://github.com/frenetic-lang/pyretic', 'https://frenetic-lang.github.io/pyretic/pubs/pyretic.pdf']",1,12_programming_SDNs,0.95,1
93,Which of the following is the appropiate Pyretic rule for sending traffic from source IP address 10.0.0.1 to destination IP address 10.1.2.3 and traffic from source IP address 10.0.0.2 to destination IP address 10.2.3.4?,"a. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2)  + mod(dstip=10.2.3.4))
b. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4))
c. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) >>mod(dstip=10.2.3.4))
d. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) + mod(dstip=10.2.3.4))
e. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) & (match(srcip=10.0.0.2)  >> mod(dstip=10.2.3.4))
",,b,b,,"In Pyretic, '>>' is sequential composition (apply a filter, then transform the matching packets) and '+' is parallel/union (combine independent policies). To match a source IP then rewrite the destination IP you must sequence match >> mod for each flow, and then combine the two independent rules with '+'. Option b correctly uses (match(...) >> mod(...)) for each mapping and '+' to union them.","['https://pyretic.readthedocs.io/en/latest/language.html', 'https://github.com/frenetic-lang/pyretic']",1,12_programming_SDNs,0.95,1
94,Which of the following might be examples that would use a dynamic policy in Pyretic? Select all that apply.,"a. Check each new traffic flow against a list of permitted and prohibited source IP addresses that may change over time.
b. Drop all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
c. Assign each new traffic flow to a different destination IP address based on a round-robin load balancing policy across servers.
d. Count all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
e. Forward traffic through the network based on shortest paths routing, re-routing traffic appropriately when links or nodes fail.
",,"a,c,e","a,c,d,e",,"In Pyretic a ""dynamic"" policy is one that maintains state or reacts to changing events/inputs over time. (a) is dynamic because the permitted/prohibited list changes and each new flow must be checked against that evolving state. (c) is dynamic because round‑robin load balancing requires maintaining and updating per‑flow allocation state. (d) is dynamic because counting traffic requires updating counters/state as packets arrive. (e) is dynamic because shortest‑path forwarding that re‑routes on link/node failures must react to topology events and update forwarding policy. (b) is a static match‑action rule (always drop 10.0.0.0/8) and does not require dynamic state or event handling, so it is not an example of a dynamic policy.","['https://github.com/frenetic-lang/pyretic', 'https://pyretic.readthedocs.io/en/latest/overview.html', 'https://frenetic-lang.org/']",0,12_programming_SDNs,0.92,1
