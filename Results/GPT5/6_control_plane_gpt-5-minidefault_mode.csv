Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
43,Which of the following statements are true about the OpenFlow specification? Select all that apply.,"a. If a switch does not contain a flow table entry that matches a particular packet, the switch forwards the packet to the controller for handling.
b. The main purpose of the OpenFlow control channel is to update flow table entries on switches.
c. The OpenFlow specification provides mechanisms to perform Layer 2 learning across a network of switches.
d. Once a switch has sent one packet for a flow, it must also send all subsequent packets for that flow to the controller.
e. Some versions of the OpenFlow specification allow for performing more than one action on a single packet.
",,"a,b,e","a,b,e",,"a: True — when no flow entry matches a packet, a switch typically generates a Packet-In (table-miss) to the controller (or performs the configured table-miss action). b: True — a primary purpose of the OpenFlow control channel is to allow the controller to add/modify/delete flow table entries on switches (though it also carries other messages). c: False — OpenFlow does not itself provide a distributed Layer‑2 learning protocol; L2 learning can be implemented by the controller using OpenFlow, but the spec does not define a built‑in L2 learning mechanism. d: False — after a Packet-In the controller commonly installs a flow entry so subsequent packets for that flow are handled by the switch locally; there is no requirement that all subsequent packets be sent to the controller. e: True — OpenFlow (in multiple versions) supports composing a list of actions to apply to a packet (e.g., set_field, push/pop headers, output), allowing multiple actions on a single packet.","['https://opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.0.0.pdf', 'https://opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.3.0.pdf', 'https://www.sigcomm.org/sites/default/files/ccr/papers/2008/July/1252241-1252244.pdf']",1,6_control_plane,0.9,1
44,Which of the following statements are true about dpctl? Select all that apply.,"a. dpctl is invoked from within the Mininet emulator.
b. dpctl can modify flow table entries on an OpenFlow switch.
c. dpctl can respond to network events, such as packets sent from a switch.
d. dpctl is an OpenFlow controller.
e. dpctl can inspect flow table entries on an OpenFlow switch.
",,"b,e","b,e",,"dpctl is a command-line utility used to inspect and manipulate datapath/OpenFlow flow tables (you can dump and add/delete flow entries). It is not an OpenFlow controller and does not itself respond to asynchronous network events from switches (that behavior is provided by controllers). While dpctl/ovs-* tools are often run on the same host where Mininet runs, dpctl is a management tool, not something that is inherently “invoked from within the Mininet emulator” as a component — so (a), (c), and (d) are false.","['https://www.openvswitch.org/support/dist-docs/ovs-ofctl.8.txt', 'https://www.openvswitch.org/support/dist-docs/ovs-dpctl.8.txt', 'http://mininet.org/walkthrough/']",1,6_control_plane,0.86,1
45,Which of the following are reasonable considerations for the choice of controller? Select all that apply.,"a. Performance of the programming language that the controller is implemented in.
b. Support for and integration with cloud applications.
c. Ease of learning curve.
d. Need for production-quality operation.
e. Speed of prototyping.
",,"a,b,c,d,e","a,b,c,d,e",,"All listed items are reasonable considerations when choosing an SDN controller: (a) implementation language can affect runtime performance and resource usage (e.g., C/Java vs. Python), (b) integration/support for cloud platforms and cloud-native apps matters for deployment and orchestration, (c) ease of learning affects developer adoption and time-to-productivity, (d) production-quality needs (HA, stability, security, clustering) determine whether a controller is suitable for operational networks, and (e) speed of prototyping is important for research or rapid feature development. The literature and project docs explicitly cite these factors when comparing controllers (performance, scalability, APIs/integration, developer experience, and production readiness).","['https://arxiv.org/abs/1406.0440 (Kreutz et al., ""Software-Defined Networking: A Comprehensive Survey"")', 'https://opennetworking.org/wp-content/uploads/2014/10/wp-sdn-newnorm.pdf (Open Networking Foundation, SDN whitepaper)', 'https://www.opendaylight.org/ (OpenDaylight project — features, production focus, integration)', 'https://onosproject.org/ (ONOS project — production/scale/HA focus)', 'https://osrg.github.io/ryu/ (Ryu controller — lightweight/prototyping, Python)', 'https://blogs.cisco.com/enterprise/choosing-an-sdn-controller (practical considerations when selecting an SDN controller)']",1,6_control_plane,0.95,1
46,Which of the following controllers support OpenStack integration? Select all that apply.,"a. NOX
b. Pox
c. CpQD
d. Floodlight
e. Ryu
",,"d,e","d,e",,"Floodlight and Ryu both provide OpenStack/Neutron integration (there are OpenStack ‘networking’ projects and Neutron drivers/plugins for these controllers). NOX and POX are primarily research/education controllers without mainstream, maintained OpenStack Neutron integration, and CPqD is known more for OpenFlow switch implementations (ofsoftswitch) rather than a widely used OpenStack controller integration.","['https://opendev.org/x/networking-floodlight', 'https://github.com/floodlightcontroller/floodlight', 'https://github.com/osrg/ryu', 'https://opendev.org/x/networking-ryu', 'https://ryu.readthedocs.io/']",1,6_control_plane,0.8,1
47,Which of the following are true about Pox? Select all that apply.,"a. Pox automatically determines the order to install flow table rules, to avoid inconsistent forwarding behavior.
b. Pox's _handle_PacketIn function determines how a packet should be handled when it arrives at the controller.
c. Pox provides a function to modify flow table entries at a switch.
d. Pox's performance is typically slower than NOX.
e. Pox automatically determines the priority between two conflicting rules.
",,"b,c,d","b,c,d",,"b: True — POX handlers implement methods like _handle_PacketIn(self, event) that are invoked on PacketIn events and decide how to process the received packet (this is how POX apps implement packet handling). c: True — POX provides APIs to construct and send OpenFlow flow modification messages (ofp_flow_mod) to switches, so controllers can add/modify flow table entries. d: True — POX is a Python-based prototype controller; NOX is implemented in C/C++ and is typically higher-performance, so POX implementations are generally slower than NOX. a and e: False — POX does not automatically compute an installation order to avoid transient inconsistent forwarding nor automatically resolve priorities between conflicting rules; that logic must be handled by the controller application (i.e., the developer sets flow installation sequencing and priority values).","['https://github.com/noxrepo/pox', 'https://noxrepo.github.io/pox/', 'https://github.com/noxrepo/pox/blob/master/pox/forwarding/l2_learning.py', 'https://github.com/noxrepo/nox']",1,6_control_plane,0.9,1
48,What is the difference between a hard timeout and an idle timeout?,"a. A hard timeout occurs exactly at the specified interval, whereas an idle timeout may occur slightly later than the specified interval.
b. A hard timeout expunges a flow table entry regardless of whether there have been active matches, whereas an idle timeout expunges the flow table entry only if there have been no matches for that flow within the specified interval.
c. A hard timeout expunges all flow table entry from the switch, whereas an idle timeout only expunges one flow at a time.
d. A hard timeout expunges a flow table entry for all switches in the network, whereas an idle timeout only expunges the flow table entry on the switches that have seen no matches for that flow within the specified interval.
",,b,b,,"In OpenFlow (and SDN flow table semantics) a hard timeout removes (expires) a flow entry after the specified time interval regardless of whether the flow has matched packets during that time. An idle timeout removes the flow entry only if no packets have matched that flow for the specified idle interval (i.e., it depends on lack of activity).","['https://opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.3.0.pdf', 'https://ryu.readthedocs.io/en/latest/ofproto_v1_3_ref.html']",1,6_control_plane,0.95,1
49,Which of the following are true about hubs and learning switches? Select all that apply,"a. A hub implemented in Pox requires all incoming packets to be directed to the controller.
b. A learning switch requires more logic at the controller (in terms of lines of code in Pox) than a hub.
c. A learning switch implemented in Pox can be easily extended to support firewall capabilities.
d. A learning switch implemented in Pox requires all incoming packets to be redirected to the controller.
e. A hub forwards an incoming packet on all ports (except the incoming port), whereas a switch only floods an incoming packet on all ports if it does not have a table entry that determines the output port for that packet.
",,"b,c,e","b,c,e",,"b: True — a learning switch maintains MAC→port state and additional logic (learning, table lookup, flow installation), so its controller implementation is larger than a simple hub. c: True — because the learning switch runs in the controller, it is straightforward to add matching/dropping rules (ACLs) or additional logic to implement firewall behavior. d: False — a learning switch typically installs flow entries in the switch so only the first packet (or packets without a matching flow) generate PacketIn events; not all packets are redirected to the controller. a: False — a hub behavior can be implemented in different ways; although many simple POX hub examples react to every PacketIn and issue PacketOuts (causing many packets to reach the controller), a hub does not intrinsically require all packets be sent to the controller (you can proactively install a wildcard flow that outputs FLOOD). e: True — by definition a hub forwards (floods) every incoming frame out all other ports, whereas a switch uses its MAC table to forward to a single port and only floods when there is no matching entry.","['https://github.com/noxrepo/pox/blob/master/pox/forwarding/hub.py', 'https://github.com/noxrepo/pox/blob/master/pox/forwarding/l2_learning.py', 'https://opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.0.0.pdf', 'Kreutz, D., Ramos, F.M.V., Verissimo, P., Rothenberg, C.E., Azodolmolky, S., Uhlig, S., ""Software-Defined Networking: A Comprehensive Survey"", Proceedings of the IEEE, 2015']",1,6_control_plane,0.86,1
50,Which of the following functions ensures that the controller will hear PacketIn messages? Select all that apply.,"a. connection.addListeners
b. _handle_PacketIn
c. AddRule
d. init
e. launch
",,a,"a,b",,"In POX the controller only receives PacketIn events if you register a listener on the switch connection (connection.addListeners), and the registered handler method processes those events (the conventionally named _handle_PacketIn method is invoked for PacketIn events). AddRule is unrelated, and while init/launch are used to set up and start components, they do not by themselves cause PacketIn delivery unless they call connection.addListeners (i.e. addListeners and the PacketIn handler are the required pieces).","['https://github.com/noxrepo/pox/blob/master/pox/forwarding/l2_learning.py', 'https://github.com/noxrepo/pox', 'https://noxrepo.github.io/pox-doc/html/']",0,6_control_plane,0.9,1
51,What are the two key steps of an OpenFlow flow table entry (select two)?,"a. match
b. action
c. redirect
d. drop
e. forward
",,"a,b","a,b",,"An OpenFlow flow table entry is composed principally of a match (which selects packets based on header fields) and actions/instructions (which tell the switch what to do with matched packets — e.g., forward, drop, modify). 'Redirect', 'drop', and 'forward' are specific actions, not the two high-level components of a flow entry.","['https://opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.3.0.pdf', 'https://en.wikipedia.org/wiki/OpenFlow', 'https://www.cl.cam.ac.uk/teaching/1617/MLRD/notes/SDN.pdf']",1,6_control_plane,0.95,1
52,Which of the following are true about the OpenDaylight controller? Select all that apply.,"a. It allows dynamic reloading of controller functionality without restarting the controller.
b. It only supports OpenFlow as a ""southbound"" control framework.
c. Its code shares a lot of similarities with Beacon.
d. Open Daylight only supports proprietary switches from Cisco and IBM.
e. It is slower and less scalable than some of the more lightweight SDN controllers such as Pox.
",,"a,c",a,,"a is true: OpenDaylight is built on an OSGi/Apache Karaf runtime which allows hot/pluggable modules and dynamic (re)loading of controller functionality without restarting the whole controller. b is false: OpenDaylight supports many southbound protocols (OpenFlow, NETCONF, OVSDB, BGP, PCEP, etc.), not only OpenFlow. c is false: Beacon is an earlier Java OpenFlow controller, but OpenDaylight is a different, modular OSGi-based platform and does not share large amounts of Beacon code. d is false: OpenDaylight is an open-source, vendor-neutral controller that supports many vendors and open standards, not only proprietary Cisco/IBM switches. e is false as stated: while lightweight controllers such as POX have a smaller footprint and may be simpler/faster for toy or lab setups, OpenDaylight is an enterprise-grade, modular platform designed for production scalability; it is not correct to categorically state it is slower and less scalable than lightweight controllers.","['https://www.opendaylight.org/', 'https://wiki.opendaylight.org/view/Architecture/Overview', 'https://www.opendaylight.org/features/', 'https://github.com/noxrepo/pox', 'https://github.com/noxrepo/beacon']",0,6_control_plane,0.9,1
