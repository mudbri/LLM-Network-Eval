Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
106,Which of the following are true about configuration verification? Select all that apply.,"a. Configuration verification can only detect errors after the configuration is installed on production routers.
b. Configuration verification cannot detect incorrect protocol behavior that may result from faulty hardware.
c. Verifying the correctness of network behavior based on configuration requires a model of protocol behavior.
d. Configuration verification requires a large-scale simulation of network protocols, complete with tests for different message orderings and timings.
e. Configuration verification cannot detect incorrect protocol behavior that may result from buggy software.
",,"b,c,e","b,c,e",,"b: True — configuration verification analyzes configs and protocol models; it cannot detect faults caused by physical hardware failures because those are outside the config/model assumptions.
c: True — to reason about end-to-end network behavior from configs you need a model of protocol/forwarding behavior (static models, formal semantics, or protocol abstractions) to predict outcomes.
d: False — verification typically uses static analysis, formal methods, or bounded model checking rather than full large-scale time/message-order simulation; it does not inherently require exhaustive timing/message-order simulations.
a: False — modern configuration verification tools (e.g., Batfish, VeriFlow, HSA/NetKAT-based tools) are explicitly used pre-deployment to find errors before configs are installed.
e: True — like hardware faults, incorrect behavior due to buggy device software/implementations is not generally detectable by config-based verification unless the bug is modeled; verification assumes correct protocol implementations.","['https://batfish.readthedocs.io/en/latest/verification.html', ""https://www.usenix.org/conference/osdi13/technical-sessions/presentation/khurshid (VeriFlow OSDI'13)"", 'https://www.cs.princeton.edu/~kazemian/papers/kazemian-nsdi13.pdf (Header Space Analysis / Kazemian et al.)', 'https://popl18.sigplan.org/details/papers/19/NetKAT-An-Overview (NetKAT / formal verification approaches)']",1,14_verification,0.95,1
107,"Which of the following assertions could be verified with configuration verification (i.e., of a snapshot of router and switch configuration)? Select all that apply.","a. A route learned from one peer will not be readvertised to another peer.
b. The current settings of link weights will result in all routers being connected.
c. The configuration of route reflectors and clients ensures that any route learned from a neighboring AS will propagate to all routers in the topology.
d. There is no traffic pattern that would ever result in a stateful firewall dropping traffic.
e. Any time that an infection occurs, hosts are automatically quarantined.
",,"a,b,c","a,b,c",,"Configuration verification (static analysis of router/switch configs and topology) can check properties that depend only on device configuration and topology: (a) whether BGP export/import policies and export filters would prevent a route learned from one peer being re-advertised to another can be determined by analyzing BGP policy and export rules; (c) whether route-reflector/client configuration and policy will cause a route learned from a neighboring AS to be propagated to all routers can be determined by examining RR/client relationships and BGP propagation policies. (b) The statement about link weights producing a connected set of routers is also verifiable from the configuration snapshot: given interfaces, neighbor definitions and link weights you can build the IGP graph and check graph connectivity (weights affect path choice but connectivity is decidable from the static topology/weights). By contrast (d) and (e) require reasoning about dynamic traffic patterns, runtime connection state, host-based detection and automation workflows (external systems, time-dependent behavior), which cannot be fully guaranteed by a one-time snapshot of router/switch configuration alone, so they are not verifiable by configuration-only verification.","['https://batfish.org/ (Batfish network configuration analysis tool and docs)', 'https://www.cs.princeton.edu/~mohsen/papers/hsa-sigcomm11.pdf (Header Space Analysis — static network verification concepts)', 'https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final27.pdf (VeriFlow — real-time network verification; contrasts static vs dynamic checks)', 'https://tools.ietf.org/html/rfc4456 (BGP Route Reflection specification)']",1,14_verification,0.88,1
108,Which of the following are true about data-plane verification? Select all that apply.,"a. Data-plane verification techniques such as header-space analysis typically operate on a single ""snapshot"" of data-plane state.
b. Data plane verification can only operate on the forwarding table of a single router or switch; network-wide analysis is not possible.
c. Data-plane verification may detect errors that configuration analysis can miss in the cases of buggy control-plane software.
d. Data-plane verification requires accurate modeling of network protocols, including which bits are present in which part of the packet header.
e. Header-space analysis can only provide verification/analysis for specific packets; it cannot answer questions for general parts of flowspace.
",,"a,c","a,c,d",,"a: True — Header-Space Analysis (HSA) and similar data‑plane techniques analyze the concrete forwarding state (tables, ACLs, transfer functions) as it exists at a point in time (a snapshot).

b: False — Data‑plane verification methods (HSA, VeriFlow, NetPlumber, etc.) are designed to reason about network‑wide forwarding by composing per‑device transfer functions across topology; they are not limited to a single device.

c: True — Because data‑plane verification inspects actual forwarding state (installed rules, TCAM entries), it can detect misbehavior caused by buggy control‑plane software or discrepancies between intended config and installed rules that configuration‑only analysis might miss.

d: True — HSA and related techniques model packet headers as bitvectors and require correct modeling of which bits/fields live where (and how matches/rewrites operate) to produce sound results.

e: False — HSA reasons about sets of headers (flowspace) via bitvector/wildcard representations, so it can answer questions about classes of packets/flowspace, not only single concrete packets.","['https://conferences.sigcomm.org/sigcomm/2012/papers/sigcomm/p387.pdf (Header Space Analysis, Kazemian et al., SIGCOMM 2012)', 'https://www.cs.rice.edu/~asanchez/papers/verification/veriflow-sigcomm12.pdf (VeriFlow: Verifying Network-Wide Invariants in Real Time, Khurshid et al., SIGCOMM 2012)', 'https://people.csail.mit.edu/jzhang/teaching/18.829/papers/netplumber.pdf (NetPlumber: Real-time network policy checking via header space)']",0,14_verification,0.9,1
109,Which of the following assertions could be verified with data plane verification? Select all that apply.,"a. The network will remain connected, given the failure of at most two links.
b. Two virtual network ""slices"" are not completely isolated: it is possible for traffic to travel from one slice to the other.
c. The configuration of the network's routing protocols will result in persistent oscillation (i.e., they will never settle on a stable set of routes).
d. The forwarding table state in the routers across the network will result in a forwarding loop.
e. The rules installed on the firewalls in the network ensure that only port 80 traffic can ever reach the web server from the rest of the Internet.
",,"b,d,e","b,d,e",,"Data‑plane verification reasons about the actual forwarding state (forwarding tables, ACLs/rules, match/action behavior) and therefore can check end‑to‑end forwarding properties: (b) whether packets can cross from one slice to another (isolation/reachability), (d) whether the installed FIBs produce a forwarding loop, and (e) whether firewall rules (ACLs) permit only port 80 to reach the server. (a) requires reasoning about network connectivity under arbitrary link failures and how the control plane will react (routing reconvergence/resilience) and so is not generally decidable from a single data‑plane snapshot alone. (c) is a control‑plane property (routing protocol dynamics/oscillation) and cannot be verified solely by data‑plane inspection.","['https://www.cs.princeton.edu/~kazemian/papers/hsa-sigcomm12.pdf (Header Space Analysis)', 'https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-agarwal.pdf (VeriFlow)', 'https://www.cs.princeton.edu/~kazemian/papers/netplumber-atc13.pdf (NetPlumber)', 'http://www.cs.rutgers.edu/~pxk/417/notes/StablePaths.pdf (The Stable Paths Problem — routing/control‑plane oscillation)']",1,14_verification,0.95,1
110,Which of the following is true about Kinetic policies? Select all that apply.,"a. State transitions can be exogenous or endogenous.
b. Kinetic's NuSMV verifier can verify that the data plane will never have loops.
c. State transitions can occur based on timing (e.g., a timeout).
d. The Kinetic controller can only process external events from routers and switches.
e. Pyretic's composition operators can help prevent state explosion.
",,"a,c,e","a,c,e",,"a) True — Kinetic models network policies as finite-state machines; transitions may be triggered by exogenous events (from outside the controller) or endogenous events/internal conditions. c) True — Kinetic supports event-driven transitions including those triggered by timers/timeouts (i.e., transitions based on timing). e) True — Kinetic is implemented on top of Pyretic; Pyretic’s composition operators (parallel/sequential composition) are used when compiling Kinetic policies and help structure and compose per-state policies rather than naively enumerating all global combinations, which mitigates state-explosion issues. b) False (misleading) — Kinetic uses the NuSMV model checker to verify properties of the modeled FSM (e.g., reachability, isolation, or user-specified invariants). While loop-freedom can be expressed and checked in the model, NuSMV only verifies the modeled specification; it does not magically prove the real, running data plane will never have loops unless the model accurately captures all relevant runtime behavior. d) False — the Kinetic controller can process both external events (from switches/routers/hosts) and internal/endogenous events (including controller-generated events and timers).","['https://www.usenix.org/system/files/conference/hotsdn13/hotsdn13_shin.pdf', 'https://nusmv.fbk.eu/ (NuSMV project page)', 'https://github.com/frenetic-lang/pyretic', 'https://pyretic.readthedocs.io/']",1,14_verification,0.85,1
112,"Which of the following NuSMV expressions encodes the statement ""It is always possible for the policy state to go to 'allow'.""","a. SPEC AG (!authenticated -> AX policy=allow)
b. None of the above.
c. SPEC A [ policy=allow U authenticated ]
d. SPEC AG (authenticated -> AX policy=allow)
e. SPEC AG (EF policy=allow)
",,e,e,,"In CTL, ""always"" is AG and ""it is possible to eventually reach"" is EF. So AG EF policy=allow expresses that in every state there exists a path that eventually reaches a state with policy=allow. Thus SPEC AG (EF policy=allow) matches the English statement. The other options either use AX (universal next), U (until) or the wrong antecedent, so they do not express ""always possible to reach allow.""","['https://nusmv.fbk.eu/NuSMV/userman/v2.6/nusmv.pdf', 'https://en.wikipedia.org/wiki/Computation_tree_logic', 'https://link.springer.com/chapter/10.1007/978-3-642-04759-2_1']",1,14_verification,0.95,1
