Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence,Score-right-minus-wrong
78,What are some of the desired features in future SDN switches that motivate a programmable data plane? Select all that apply.,"a. Reducing energy consumption for custom packet processing.
b. Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel.
c. A wider range of packet processing primitives.
d. A configurable packet parser that is not tied to a specific header format.
e. Processing packets at higher rates.
",,"b,c,d","b,c,d",,"Some of the desired features in future SDN switches that motivate a programmable data plane include:b) Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel. This allows for more complex and customizable packet processing pipelines.  c) A wider range of packet processing primitives beyond simple match-action, such as the ability to perform stateful operations or custom computations on packet data. This enables switches to handle more advanced networking functions.d) A configurable packet parser that is not tied to a specific header format. This allows the switch to handle new or custom protocols without being limited by a fixed parsing logic.","['Nick Feamster, Jennifer Rexford, Ellen Zegura. The Road to SDN: An Intellectual History of Programmable Networks. ACM Queue, 2014.', 'Pat Bosshart et al. P4: Programming Protocol-Independent Packet Processors. ACM SIGCOMM Computer Communication Review, 2014.']",1,11_protocol_independent_forwarding,0.9,1,1.0
79,Which of the following best describes protocol independence?,"a. The ability to run a switch independently from the controller.
b. The ability to run a network with both legacy OpenFlow switches and switches that support custom packet processing.
c. The ability to configure a packet parser in hardware that is agnostic to (and not constrained by) the control protocol.
d. The ability to evolve an existing control protocol without breaking interoperability.
e. The ability to support multiple protocols running in parallel on the same hardware.
",,c,c,,"Protocol independence refers to the ability to configure a packet parser in hardware that is agnostic to and not constrained by the control protocol used. This allows the data plane hardware to parse and process packets independently of the specific control protocol, enabling flexibility in the choice and evolution of control protocols without requiring changes to the underlying hardware.","['Software-Defined Networks: A Systems Approach by Bruce Davie, Larry Peterson (2019)', 'Software Defined Networking (SDN): Anatomy of OpenFlow Volume I by Doug Marschke, Jeff Doyle, Pete Moyer (2015)']",1,11_protocol_independent_forwarding,0.9,1,1.0
81,Which of the following describe functions of the P4 parser? Select all that apply.,"a. Constructing a graph of dependencies between different logical tables.
b. Translating a packet processing specification to a state machine.
c. Mapping logical tables to underlying switch resources.
d. Translating rules to physical tables.
e. Verifying that the description of packet parsing is consistent with the behavior of an existing hardware switch (e.g., a legacy OpenFlow switch).
",,"b,e",b,,"The P4 parser is responsible for translating a packet processing specification into a state machine that extracts the required fields from the packet. It does not construct dependency graphs, map logical tables to switch resources, translate rules to physical tables, or verify parsing behavior against existing hardware switches.","['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html#sec-packet-parsing', 'https://opennetworking.org/wp-content/uploads/2020/12/P4_Tutorial.pdf']",0,11_protocol_independent_forwarding,0.9,1,0.6000000000000001
82,"Which of the following best describe the relationship between a language like P4, an assembler like NetASM, and target programmable hardware (e.g., RMT)?","a. A language like NetASM would ""compile"" to an assembly language like P4, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
b. A language like P4 would ""compile"" to an assembly language like NetASM, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
c. P4 is much more amenable to ""cost semantics"" (i.e., figuring out how much a particular operation would cost in terms of power or area) than NetASM.
NetASM and P4 are two examples of high-level programming languages; they are interchangeable.
d. P4 has verifiable semantics, whereas NetASM does not.
",,b,b,,"P4 is a high-level language for programming the data plane of network devices. It allows expressing packet processing logic in a target-independent manner. NetASM, on the other hand, is a lower-level assembly language that provides a one-to-one mapping to the underlying hardware resources. In the compilation process, P4 code would be translated into a lower-level representation like NetASM, which would then directly map to the specific resources available on the target forwarding hardware such as RMT (Reconfigurable Match Tables).","['The P4 Language Specification, Version 1.0.0, https://p4.org/p4-spec/p4-14/v1.0.0/tex/p4.pdf', 'NetASM: A Low-Level Assembly Language for Programmable Packet Processing, https://dl.acm.org/doi/10.1145/2619239.2626323', 'RMT: Reconfigurable Match Tables for High-Performance Packet Classification and Forwarding, https://dl.acm.org/doi/10.1145/2934872.2934897']",1,11_protocol_independent_forwarding,0.9,1,1.0
83,Which of the folloiwing instruction types create state elements in NetASM? Select all that apply.,"a. MKR
b. LBL
c. DRP
d. JMP
e. MKT
",,"a,e","a,e",,"In NetASM, the MKR (Make Record) and MKT (Make Table) instructions are used to create state elements. MKR creates a record, which is a stateful data structure that can hold multiple fields. MKT creates a table, which is a key-value store that can be used for lookups and updates. The other instructions - LBL (Label), DRP (Drop), and JMP (Jump) - do not directly create state elements.","['NetASM: A Low-Level Assembly Language for Packet Processing on Network Processors. Mihai Budiu, Girish Venkataramani, Tiberiu Chelcea, and Seth Copen Goldstein. 2004.', 'The NetASM Assembly Language. https://github.com/NetASM/NetASM-python/wiki/The-NetASM-Assembly-Language']",1,11_protocol_independent_forwarding,0.9,1,1.0
84,Which of the following are true about locally contained applications? Select all that apply.,"a. Locally contained applications forward packets more slowly than their stateless counterparts.
b. Locally contained applications allow the hardware pipeline to make switch-local state modifications.
c. Locally contained applications can be implemented with regular OpenFlow instructions.
d. A locally contained application can implement SDN logic without ever requiring a packet to be sent to the controller.
e. A MAC learning switch can be implemented as a locally contained application.
",,"b,d,e","b,d,e",,"Locally contained applications allow the hardware pipeline to make switch-local state modifications without needing to send packets to the controller. This enables implementing SDN logic, such as a MAC learning switch, directly on the switch. Locally contained applications can forward packets at line rate, unlike stateless applications that may need to send packets to the controller, introducing latency. While OpenFlow alone is stateless, vendor extensions to OpenFlow can enable stateful, locally contained applications on the switch.","['https://www.opennetworking.org/wp-content/uploads/2013/02/TR_SDN_ARCH_1.0_06062014.pdf', 'https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf']",1,11_protocol_independent_forwarding,0.9,1,1.0
86,What are some examples of optimizations that a compiler could perform on NetASM instructions? Select all that apply.,"a. Preventing bufferbloat for real-time application traffic.
b. Reordering instructions so that subsequent tables need not be as large (e.g., not storing state for unmatched packets).
c. Forwarding packets for high-volume flows at higher rates.
d. Only instantiating hardware resources (e.g., table entries) for flows that actually have nonzero traffic volume.
e. Composing or decomposing tables to save either on table size or table width.
",,"b,d,e","b,d,e",,"A compiler could optimize NetASM instructions in the following ways:b) Reordering instructions to reduce the size of subsequent tables by not storing state for unmatched packets. This avoids wasting memory.  d) Only instantiating hardware resources like table entries for flows that actually have traffic, to avoid wasting resources on inactive flows.e) Composing or decomposing tables to optimize either the number of tables or the width of each table. This allows balancing memory usage.Choices a) and c) relate to runtime packet processing behaviors rather than compile-time instruction optimizations.","['NetASM: A Low-Level Assembly Language for Packet Processing on Programmable Hardware - Sivaraman et al., SIGCOMM 2020', 'Domino: A High-Level Language and Compiler for Packet Processing Hardware - Sivaraman et al., PLDI 2016']",1,11_protocol_independent_forwarding,0.95,1,1.0
