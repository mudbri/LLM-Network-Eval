Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence,Score-right-minus-wrong
113,"Which are reasonable approaches for designing a fast, scalable, programmable data plane? Select all that apply.","a. Make software routers faster by amortizing packet-processing costs across batches of packets.
b. Make software routers faster by reducing the need to copy packets from the kernel into user space.
c. Make software routers faster by distributing software routers across clusters.
d. Make hardware routers more programmable with custom OpenFlow chips.
e. Send all traffic through software switches running in user space.
",,"a,b,c,d","a,b,c,d",,"Reasonable approaches for designing a fast, scalable, programmable data plane include:a) Amortizing packet-processing costs across batches of packets in software routers to improve performance. b) Reducing the need to copy packets from kernel to user space in software routers to reduce overhead.c) Distributing software routers across clusters to scale out performance.d) Making hardware routers more programmable with custom OpenFlow chips.Sending all traffic through user-space software switches (e) is not a reasonable approach as it would introduce significant performance overhead compared to kernel-based or hardware forwarding.","['Nick Feamster, Jennifer Rexford, and Ellen Zegura. 2014. The Road to SDN: An Intellectual History of Programmable Networks. SIGCOMM Comput. Commun. Rev. 44, 2 (April 2014), 87–98. https://doi.org/10.1145/2602204.2602219', 'Pat Bosshart, Dan Daly, Glen Gibb, Martin Izzard, Nick McKeown, Jennifer Rexford, Cole Schlesinger, Dan Talayco, Amin Vahdat, George Varghese, and David Walker. 2014. P4: Programming Protocol-Independent Packet Processors. SIGCOMM Comput. Commun. Rev. 44, 3 (July 2014), 87–95. https://doi.org/10.1145/2656877.2656890']",1,10_programmable_data_planes,0.9,1,1.0
114,What are functions that are commonly performed by a programmable data plane? Select all that apply.,"a. Computing routes
b. Shaping traffic
c. Forwarding
d. Specifying access control policies
e. Performing deep packet inspection
",,"b,c,e","b,c,e",,"The programmable data plane in software defined networking commonly performs traffic shaping (b) to control bandwidth usage, packet forwarding (c) based on defined rules, and deep packet inspection (e) to analyze packet contents. Computing routes (a) is typically a control plane function, while access control policies (d) may span both control and data planes depending on implementation.","['Software Defined Networks: A Comprehensive Approach, Second Edition by Paul Goransson, Chuck Black', 'Software-Defined Networking (SDN) with OpenFlow by Siamak Azodolmolky', 'https://www.opennetworking.org/sdn-definition/']",1,10_programmable_data_planes,0.9,1,1.0
115,Which of the following functions might be performed by a Click element? Select all that apply.,"a. Dropping packets
b. Reading a packet from a network device
c. Computing shortest paths routes between two routers
d. Counting packets
e. Classifying packets into different priority queues
",,"a,b,d,e","a,b,d,e",,"In the Click modular router architecture, a Click element can perform various packet processing functions. These include dropping packets (a), reading a packet from a network device (b), counting packets (d), and classifying packets into different priority queues (e). However, computing shortest path routes between two routers (c) is typically not done by an individual Click element, but rather by the routing protocols running on the routers.","['Kohler, Eddie, et al. ""The click modular router."" ACM Transactions on Computer Systems (TOCS) 18.3 (2000): 263-297.', 'https://github.com/kohler/click/wiki/Elements']",1,10_programmable_data_planes,0.9,1,1.0
116,Which of the following are true about programmable data planes in Click? Select all that apply.,"a. Click configuration is a simplified version of Python.
b. Click elements can be composed to perform complex functions, such as the forwarding at an IP router.
c. Data-plane processing in Click is limited to a fixed set of elements provided by the software.
d. Click elements can be composed to perform complex network-wide functions, such as shortest paths or BGP routing.
e. Click elements cannot perform common data plane operations such as TTL decrement or checksum computations.
",,b,b,,"In Click, elements are the basic building blocks that can be composed to perform complex packet processing functions. Elements can be combined to implement the forwarding logic of an IP router, which involves operations like header parsing, route lookup, TTL decrement, checksum updates, etc. However, Click configuration uses its own domain-specific language, not Python (eliminating option a). The elements in Click are extensible and not limited to a fixed set (eliminating option c). While elements can be composed for packet processing, Click itself does not provide higher-level network functions like shortest path or BGP computations (eliminating option d). Lastly, common data plane operations like TTL and checksum handling are supported in Click elements (eliminating option e). Therefore, only option b correctly describes the programmable data plane capabilities of Click.","['Kohler, Eddie, et al. ""The Click modular router."" ACM Transactions on Computer Systems (TOCS) 18.3 (2000): 263-297.', 'https://github.com/kohler/click/wiki/Click-Documentation']",1,10_programmable_data_planes,0.95,1,1.0
117,Why does a RouteBricks server assign one core per queue?,"a. Cores have heterogeneous performance, and packets are different sizes, so it makes sense to assign less powerful cores to queues that have smaller packets.
b. Having multiple cores accessing the same queue might create the possibility that there is a queue that is not served by any cores.
c. Having multiple cores accessing the same queue would require each core to perform only one function in the packet processing pipeline, which is inefficient.
d. Having multiple cores accessing the same queue would require locking to prevent concurrent memory accesses, slowing packet forwarding performance.
",,d,d,,"The RouteBricks server assigns one core per queue to avoid the need for locking when multiple cores access the same queue. If multiple cores were accessing the same queue, it would require locking mechanisms to prevent concurrent memory accesses to the queue data structure. This locking overhead would slow down the packet forwarding performance. By assigning a dedicated core to each queue, RouteBricks eliminates the need for locking and allows each core to process packets from its assigned queue independently, maximizing forwarding performance.","['RouteBricks: Exploiting Parallelism to Scale Software Routers, Dobrescu et al., ACM SIGOPS 22nd Symposium on Operating Systems Principles, 2009', 'https://www.cs.princeton.edu/courses/archive/fall13/cos561/papers/RouteBricks09.pdf']",1,10_programmable_data_planes,0.95,1,1.0
118,What are some tricks commonly employed in software to accelerate packet forwarding? Select all that apply.,"a. Batch processing
b. Large packet buffers that hold multiple packets that can be read with a single read
c. Ethernet GRE tunnels
d. Forwarding smaller packets before larger packets
e. Avoiding lookups on the software bridge between virtual interfaces and physical interfaces
",,"a,b,c,e","a,b",,"Batch processing (a) and using large packet buffers to hold multiple packets that can be read with a single read (b) are two common tricks used in software to accelerate packet forwarding. Batch processing allows multiple packets to be processed together, amortizing the per-packet processing overhead. Large packet buffers enable reading multiple packets in a single read operation, reducing the number of system calls and context switches required. Ethernet GRE tunnels (c) are not specifically a packet forwarding acceleration technique. Forwarding smaller packets before larger ones (d) is not a common acceleration approach. Avoiding lookups on the software bridge (e) could help, but is not one of the most common tricks employed.","['https://www.usenix.org/system/files/conference/nsdi17/nsdi17-firestone.pdf', 'https://www.kernel.org/doc/html/latest/networking/scaling.html']",0,10_programmable_data_planes,0.9,1,0.1999999999999999
119,What are some of the problems with current OpenFlow hardware that motivated a custom OpenFlow chip design? Select all that apply.,"a. Current hardware cannot forward traffic at line rates.
b. Current hardware is difficult to repurpose in the field.
c. Current hardware cannot support OpenFlow 1.0 match-action primitives.
d. Current hardware makes it difficult to implement multiple match action stages, and to repurpose TCAM and SRAM across multiple match-action stages.
e. The current OpenFlow protocol depends on the constraints of conventional switching chips.
",,"b,d,e","b,d",,"The main problems with current OpenFlow hardware that motivated a custom chip design are: b) Current hardware is difficult to repurpose in the field, and d) Current hardware makes it difficult to implement multiple match action stages, and to repurpose TCAM and SRAM across multiple match-action stages. Conventional switching chips have fixed functionality that is difficult to modify or extend after deployment. They also have limitations in supporting flexible match-action processing across multiple stages and reallocating memory resources like TCAM and SRAM between stages, which is desirable for OpenFlow switches.","['McKeown, Nick, et al. ""OpenFlow: enabling innovation in campus networks."" ACM SIGCOMM Computer Communication Review 38.2 (2008): 69-74.', 'Bosshart, Pat, et al. ""P4: Programming protocol-independent packet processors."" ACM SIGCOMM Computer Communication Review 44.3 (2014): 87-95.']",0,10_programmable_data_planes,0.9,1,0.6000000000000001
120,"Which of the following are motivations for SwitchBlade, which supports composition of pre-synthesized hardware data plane modules on an FPGA? Select all that apply.","a. Programming in C is difficult.
b. Most data plane protocols involve composing only a limited number of data-plane actions.
c. FPGAs are lower-cost and consume less power than conventional ASICs or OpenFlow switching chips.
d. Experimental data planes may need to operate in parallel with production data planes.
e. Programming in Verilog is difficult.
",,"b,d,e","b,d",,"The motivations for SwitchBlade's approach of composing pre-synthesized hardware data plane modules on an FPGA are:b) Most data plane protocols involve composing only a limited number of data-plane actions. By providing pre-synthesized modules for common actions, SwitchBlade simplifies building custom data planes.  d) Experimental data planes may need to operate in parallel with production data planes. Using an FPGA allows SwitchBlade to implement experimental data planes alongside production ones on the same hardware.Choices a, c, and e are incorrect. The difficulty of programming in C or Verilog is not directly relevant. While FPGAs are more flexible than ASICs, lower cost and power are not the primary motivations presented for SwitchBlade.","['SwitchBlade: A Platform for Rapid Deployment of Network Protocols on Programmable Hardware, Anwer et al., SIGCOMM 2010', 'https://www.cs.princeton.edu/~jrex/papers/switchblade10.pdf']",0,10_programmable_data_planes,0.9,1,0.6000000000000001
