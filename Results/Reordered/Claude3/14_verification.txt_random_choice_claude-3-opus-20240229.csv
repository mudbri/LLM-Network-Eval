Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence,Score-right-minus-wrong
106,Which of the following are true about configuration verification? Select all that apply.,"a. Configuration verification requires a large-scale simulation of network protocols, complete with tests for different message orderings and timings.
b. Configuration verification cannot detect incorrect protocol behavior that may result from faulty hardware.
c. Configuration verification cannot detect incorrect protocol behavior that may result from buggy software.
d. Verifying the correctness of network behavior based on configuration requires a model of protocol behavior.
e. Configuration verification can only detect errors after the configuration is installed on production routers.
",,"b,c,d","b,d",,"Configuration verification requires a model of the intended protocol behavior in order to check if the configuration will produce the correct network behavior (d). However, it cannot detect issues caused by faulty hardware (b) since it only analyzes the configuration, not the physical equipment. Large-scale protocol simulation (a) is not necessary, as verification focuses on the configuration. Buggy router software (c) and errors before production deployment (e) are also detectable by configuration verification.","['Prabhu, Raj. Software Defined Networking (SDN): Anatomy of OpenFlow. Apress, 2021.', 'Goransson, Paul, Chuck Black, and Timothy Culver. Software Defined Networks: A Comprehensive Approach. Morgan Kaufmann, 2016.']",0,14_verification,0.9,1,0.6000000000000001
107,"Which of the following assertions could be verified with configuration verification (i.e., of a snapshot of router and switch configuration)? Select all that apply.","a. There is no traffic pattern that would ever result in a stateful firewall dropping traffic.
b. A route learned from one peer will not be readvertised to another peer.
c. Any time that an infection occurs, hosts are automatically quarantined.
d. The current settings of link weights will result in all routers being connected.
e. The configuration of route reflectors and clients ensures that any route learned from a neighboring AS will propagate to all routers in the topology.
",,"b,d,e","b,d,e",,"Configuration verification can check static properties of the network configuration, but not dynamic behavior or events. Choices b, d, and e involve static configuration settings that could be verified:b. Checking route advertisement filters between peers.  d. Analyzing the link weight settings to ensure all routers are reachable.e. Verifying route reflector and client configuration propagates external routes.Choices a and c involve dynamic events (traffic patterns causing drops, infections occurring) that cannot be verified solely from configuration.","['https://www.cs.princeton.edu/~jrex/papers/veriflow13.pdf', 'https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-fogel.pdf']",1,14_verification,0.9,1,1.0
108,Which of the following are true about data-plane verification? Select all that apply.,"a. Data-plane verification may detect errors that configuration analysis can miss in the cases of buggy control-plane software.
b. Data plane verification can only operate on the forwarding table of a single router or switch; network-wide analysis is not possible.
c. Data-plane verification requires accurate modeling of network protocols, including which bits are present in which part of the packet header.
d. Data-plane verification techniques such as header-space analysis typically operate on a single ""snapshot"" of data-plane state.
e. Header-space analysis can only provide verification/analysis for specific packets; it cannot answer questions for general parts of flowspace.
",,"a,d","a,c,d",,"Data-plane verification can detect errors missed by configuration analysis if there are bugs in the control-plane software (a). It requires accurate modeling of network protocols and packet header fields (c). Techniques like header-space analysis typically operate on a single snapshot of the data-plane state (d). However, data-plane verification is not limited to a single device and can perform network-wide analysis (b is incorrect). Header-space analysis is also not limited to specific packets and can answer questions about general parts of the flow space (e is incorrect).","['https://www.cs.cornell.edu/~jnfoster/papers/frenetic-icfp.pdf', 'https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-khurshid.pdf']",0,14_verification,0.9,1,0.6000000000000001
109,Which of the following assertions could be verified with data plane verification? Select all that apply.,"a. The rules installed on the firewalls in the network ensure that only port 80 traffic can ever reach the web server from the rest of the Internet.
b. The configuration of the network's routing protocols will result in persistent oscillation (i.e., they will never settle on a stable set of routes).
c. The network will remain connected, given the failure of at most two links.
d. Two virtual network ""slices"" are not completely isolated: it is possible for traffic to travel from one slice to the other.
e. The forwarding table state in the routers across the network will result in a forwarding loop.
",,"a,d,e","a,d,e",,"Data plane verification focuses on analyzing the actual forwarding behavior of the network based on the installed forwarding rules and configurations. It can verify properties related to reachability, isolation, and forwarding correctness.a) Verifying that only port 80 traffic from the Internet can reach the web server is a reachability property that data plane verification can check by analyzing the forwarding rules on the firewalls.d) Verifying the isolation between virtual network slices is also within the scope of data plane verification. It can analyze the forwarding rules to determine if traffic can leak from one slice to another.e) Detecting forwarding loops is a key capability of data plane verification. By analyzing the forwarding table state across the network, it can identify if packets may get stuck in a loop.b) Verifying routing protocol convergence and oscillation is typically done through control plane verification, not data plane verification.c) Verifying network connectivity under link failures is more of a control plane property. Data plane verification primarily focuses on the current forwarding state.","['https://www.cs.princeton.edu/~jrex/papers/veriflow13.pdf', 'https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final127.pdf', 'https://dl.acm.org/doi/10.1145/3387514.3405868']",1,14_verification,0.9,1,1.0
110,Which of the following is true about Kinetic policies? Select all that apply.,"a. Kinetic's NuSMV verifier can verify that the data plane will never have loops.
b. The Kinetic controller can only process external events from routers and switches.
c. Pyretic's composition operators can help prevent state explosion.
d. State transitions can occur based on timing (e.g., a timeout).
e. State transitions can be exogenous or endogenous.
",,"c,d,e","c,d,e",,"Kinetic policies can leverage Pyretic's composition operators to help prevent state explosion (c). State transitions in Kinetic policies can occur based on timing events like timeouts (d) and can be triggered by both external (exogenous) events and internal (endogenous) events (e). However, Kinetic's NuSMV verifier checks for crash-freedom and bounded-execution, not loop-freedom in the data plane (a is incorrect). The Kinetic controller can process external events beyond just those from routers and switches, such as from end hosts (b is incorrect).","['Kinetic: Verifiable Dynamic Network Control, H. Kim, et al., NSDI 2015', 'Pyretic: A Language and Runtime System for Network Programming, J. Reich, et al., SOSP 2013']",1,14_verification,0.9,1,1.0
112,"Which of the following NuSMV expressions encodes the statement ""It is always possible for the policy state to go to 'allow'.""","a. SPEC AG (EF policy=allow)
b. SPEC AG (authenticated -> AX policy=allow)
c. SPEC AG (!authenticated -> AX policy=allow)
d. None of the above.
e. SPEC A [ policy=allow U authenticated ]
",,a,a,,"The given statement can be encoded in CTL as 'AG (EF policy=allow)'. This reads as 'for All paths, Globally it is the case that there Exists a Future state where policy=allow'. In other words, from any state it is always possible to eventually reach a state where policy becomes 'allow'. This matches the meaning of the original statement.","['Principles of Model Checking by Christel Baier and Joost-Pieter Katoen, which covers CTL syntax and semantics', 'NuSMV tutorial and user manual that provides examples of specifying properties in CTL using NuSMV expressions']",1,14_verification,0.9,1,1.0
