Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
78,What are some of the desired features in future SDN switches that motivate a programmable data plane? Select all that apply.,"a. Reducing energy consumption for custom packet processing.
b. Processing packets at higher rates.
c. A wider range of packet processing primitives.
d. Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel.
e. A configurable packet parser that is not tied to a specific header format.
",,"c,d,e","b,c,d,e",,Some of the desired features in future SDN switches that motivate a programmable data plane include:b) Processing packets at higher rates - A programmable data plane allows optimizing packet processing pipelines for higher throughput.  c) A wider range of packet processing primitives - Programmability enables implementing custom packet processing logic beyond fixed-function ASICs.d) Flexible match-action tables - Composing match-action tables in sequence or parallel allows greater flexibility in defining forwarding behavior.e) A configurable packet parser - Parsing packets with custom header formats requires a parser not tied to specific fields.Reducing energy consumption (a) is a general goal but not a direct motivation for data plane programmability.,"['https://opennetworking.org/wp-content/uploads/2013/04/Whitepaper-Software-Defined-Networking-Done-Right.pdf', 'https://www.usenix.org/system/files/conference/nsdi17/nsdi17-bosshart.pdf']",0,11_protocol_independent_forwarding,0.9,1
79,Which of the following best describes protocol independence?,"a. The ability to configure a packet parser in hardware that is agnostic to (and not constrained by) the control protocol.
b. The ability to evolve an existing control protocol without breaking interoperability.
c. The ability to run a switch independently from the controller.
d. The ability to support multiple protocols running in parallel on the same hardware.
e. The ability to run a network with both legacy OpenFlow switches and switches that support custom packet processing.
",,a,d,,"Protocol independence refers to the ability to support multiple protocols running in parallel on the same hardware. This allows the network to evolve and adopt new protocols without requiring a complete overhaul of the hardware infrastructure. The other options, while related to SDN concepts, do not directly define protocol independence.","['Software-Defined Networking (SDN): Anatomy of OpenFlow Volume I by Doug Marschke, Jeff Doyle, Pete Moyer (2015)', 'https://www.opennetworking.org/sdn-definition/', 'https://www.sdxcentral.com/networking/sdn/definitions/what-is-protocol-independence/']",0,11_protocol_independent_forwarding,0.9,1
81,Which of the following describe functions of the P4 parser? Select all that apply.,"a. Constructing a graph of dependencies between different logical tables.
b. Translating rules to physical tables.
c. Verifying that the description of packet parsing is consistent with the behavior of an existing hardware switch (e.g., a legacy OpenFlow switch).
d. Translating a packet processing specification to a state machine.
e. Mapping logical tables to underlying switch resources.
",,"c,d",d,,The P4 parser is responsible for translating the packet processing specification defined in P4 into a state machine that can be executed by the underlying hardware. It takes the P4 program as input and generates the logic for parsing packets according to the defined header formats and extraction order.,"['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html#sec-parsing', 'https://opennetworking.org/wp-content/uploads/2020/12/P4_Tutorial.pdf']",0,11_protocol_independent_forwarding,0.9,1
82,"Which of the following best describe the relationship between a language like P4, an assembler like NetASM, and target programmable hardware (e.g., RMT)?","a. P4 is much more amenable to ""cost semantics"" (i.e., figuring out how much a particular operation would cost in terms of power or area) than NetASM.
NetASM and P4 are two examples of high-level programming languages; they are interchangeable.
b. P4 has verifiable semantics, whereas NetASM does not.
c. A language like P4 would ""compile"" to an assembly language like NetASM, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
d. A language like NetASM would ""compile"" to an assembly language like P4, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
",,c,c,,"P4 is a high-level language for programming the data plane of network devices. It provides an abstraction layer that allows developers to define packet processing behavior without needing to understand the underlying hardware details. NetASM, on the other hand, is a lower-level assembly language that provides a more direct mapping to the hardware resources. In a typical workflow, P4 code would be compiled to NetASM, which would then be used to configure the target hardware (e.g., RMT - Reconfigurable Match Tables) in a one-to-one relationship.","['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html', 'https://www.usenix.org/system/files/nsdi19-zhuo.pdf', 'https://opennetworking.org/wp-content/uploads/2020/12/P4_tutorial_01_basics.pdf']",1,11_protocol_independent_forwarding,0.9,1
83,Which of the folloiwing instruction types create state elements in NetASM? Select all that apply.,"a. JMP
b. DRP
c. LBL
d. MKT
e. MKR
",,"d,e","d,e",,"In NetASM, the MKT (Make Tag) and MKR (Make Register) instructions are used to create state elements. MKT creates a tag, which is a named memory location that can store a value. MKR creates a register, which is a storage element that can hold a value and be read from or written to. The other instructions - JMP (Jump), DRP (Drop), and LBL (Label) - do not directly create state elements.","['NetASM: A Low-level Assembly Language for Packet Processing on Network Processors. Mihai Budiu, Girish Venkataramani, Tiberiu Chelcea, and Seth Copen Goldstein. 2004.', 'https://www.cs.cmu.edu/~seth/papers/budiu-netasm-tr.pdf']",1,11_protocol_independent_forwarding,0.9,1
84,Which of the following are true about locally contained applications? Select all that apply.,"a. Locally contained applications can be implemented with regular OpenFlow instructions.
b. A MAC learning switch can be implemented as a locally contained application.
c. Locally contained applications forward packets more slowly than their stateless counterparts.
d. A locally contained application can implement SDN logic without ever requiring a packet to be sent to the controller.
e. Locally contained applications allow the hardware pipeline to make switch-local state modifications.
",,"b,d,e","b,d,e",,"Locally contained applications can implement certain SDN logic without requiring packets to be sent to the controller. They allow the hardware pipeline to make switch-local state modifications. A MAC learning switch is an example of a locally contained application that can be implemented this way. However, locally contained applications cannot be implemented with regular OpenFlow instructions - they require special support. Also, locally contained applications do not necessarily forward packets more slowly than stateless applications.","['Nick Feamster, Jennifer Rexford, and Ellen Zegura. 2014. The Road to SDN: An Intellectual History of Programmable Networks. ACM Queue 12, 2 (February 2014), 20 pages. https://doi.org/10.1145/2559899.2560327', 'Nate Foster, et al. 2013. Languages for software-defined networks. IEEE Communications Magazine 51, 2 (February 2013), 128-134. https://doi.org/10.1109/MCOM.2013.6461197']",1,11_protocol_independent_forwarding,0.9,1
86,What are some examples of optimizations that a compiler could perform on NetASM instructions? Select all that apply.,"a. Preventing bufferbloat for real-time application traffic.
b. Forwarding packets for high-volume flows at higher rates.
c. Composing or decomposing tables to save either on table size or table width.
d. Only instantiating hardware resources (e.g., table entries) for flows that actually have nonzero traffic volume.
e. Reordering instructions so that subsequent tables need not be as large (e.g., not storing state for unmatched packets).
",,"c,d,e","c,d,e",,"A compiler for NetASM instructions could perform optimizations such as:c) Composing or decomposing tables to optimize table size or width. This could involve combining similar tables or splitting large tables.  d) Only instantiating hardware resources like table entries for flows that actually have traffic, to avoid wasting resources on unused flows.e) Reordering instructions so that tables processed later can be smaller, such as not storing state for packets that don't match earlier tables.Choices a) and b) relate more to runtime packet processing rather than compile-time instruction optimization.","['A Compiler and Run-time System for Network Programming Languages, Kohler et al., 2012', 'Compiling Packet Programs to Reconfigurable Switches, Sivaraman et al., NSDI 2015']",1,11_protocol_independent_forwarding,0.9,1
