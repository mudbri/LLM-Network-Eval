Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
78,What are some of the desired features in future SDN switches that motivate a programmable data plane? Select all that apply.,"a. Reducing energy consumption for custom packet processing.
b. Processing packets at higher rates.
c. A wider range of packet processing primitives.
d. Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel.
e. A configurable packet parser that is not tied to a specific header format.
",,"c,d,e","b,c,d,e",,Some desired features in future SDN switches that motivate a programmable data plane include: b) Processing packets at higher rates to handle increasing network speeds and traffic volumes. c) Supporting a wider range of packet processing primitives beyond basic forwarding to enable more advanced network functions. d) Allowing flexible composition of match-action tables to support complex packet processing pipelines. e) Having a configurable packet parser not tied to specific header formats to handle new protocols. Reducing energy consumption (a) is a general goal but not a key motivator for programmable data planes specifically.,"['Nick Feamster, Jennifer Rexford, Ellen Zegura. The Road to SDN: An Intellectual History of Programmable Networks. ACM Queue, 2014.', 'Pat Bosshart, et al. P4: Programming Protocol-Independent Packet Processors. ACM SIGCOMM Computer Communication Review, 2014.', 'Nate Foster, et al. Languages for Software-Defined Networks. IEEE Communications Magazine, 2013.']",0,11_protocol_independent_forwarding,0.95,1
79,Which of the following best describes protocol independence?,"a. The ability to configure a packet parser in hardware that is agnostic to (and not constrained by) the control protocol.
b. The ability to evolve an existing control protocol without breaking interoperability.
c. The ability to run a switch independently from the controller.
d. The ability to support multiple protocols running in parallel on the same hardware.
e. The ability to run a network with both legacy OpenFlow switches and switches that support custom packet processing.
",,a,a,,"Protocol independence refers to the ability to configure a packet parser in hardware that is agnostic to and not constrained by the control protocol. This allows the data plane to be programmed independently of the control plane protocol being used. The other options, while related to SDN concepts, do not directly describe protocol independence.","['Software Defined Networks: A Comprehensive Approach, Second Edition by Paul Goransson, Chuck Black, and Timothy Culver (Chapter 4 - The OpenFlow Specification)', 'https://www.opennetworking.org/sdn-definition/']",1,11_protocol_independent_forwarding,0.9,1
81,Which of the following describe functions of the P4 parser? Select all that apply.,"a. Constructing a graph of dependencies between different logical tables.
b. Translating rules to physical tables.
c. Verifying that the description of packet parsing is consistent with the behavior of an existing hardware switch (e.g., a legacy OpenFlow switch).
d. Translating a packet processing specification to a state machine.
e. Mapping logical tables to underlying switch resources.
",,"c,d",d,,"The main function of the P4 parser is to translate the packet processing specification defined in the P4 program into a state machine that can parse and extract relevant header fields from incoming packets. It does not construct dependency graphs, translate rules, verify consistency with existing hardware, or map to underlying resources - those are functions of the P4 compiler and target-specific backends.","['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html#sec-parsing', 'https://opennetworking.org/wp-content/uploads/2020/12/P4_Tutorial.pdf']",0,11_protocol_independent_forwarding,0.9,1
82,"Which of the following best describe the relationship between a language like P4, an assembler like NetASM, and target programmable hardware (e.g., RMT)?","a. P4 is much more amenable to ""cost semantics"" (i.e., figuring out how much a particular operation would cost in terms of power or area) than NetASM.
NetASM and P4 are two examples of high-level programming languages; they are interchangeable.
b. P4 has verifiable semantics, whereas NetASM does not.
c. A language like P4 would ""compile"" to an assembly language like NetASM, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
d. A language like NetASM would ""compile"" to an assembly language like P4, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
",,c,c,,"P4 is a high-level programming language for software-defined networking, while NetASM is a lower-level assembly language. P4 code would typically be compiled to NetASM, which would then map directly to the resources available on the target hardware like RMT (Reconfigurable Match Tables). This allows P4 to provide a higher level of abstraction and portability across different hardware targets, while NetASM provides a more direct mapping to the underlying hardware resources.","['The P4 Language Specification, Version 1.0.0, https://p4.org/p4-spec/p4-14/v1.0.0/tex/p4.pdf', 'NetASM: A Low-level Assembly Language for Programmable Packet Processing, https://dl.acm.org/doi/10.1145/2619239.2626315']",1,11_protocol_independent_forwarding,0.9,1
83,Which of the folloiwing instruction types create state elements in NetASM? Select all that apply.,"a. JMP
b. DRP
c. LBL
d. MKT
e. MKR
",,"d,e","d,e",,"In NetASM, the MKT (make table) and MKR (make register) instructions are used to create state elements. MKT creates a match-action table, while MKR creates a register. The other instructions - JMP (jump), DRP (drop packet), and LBL (label) - do not create state elements.","['NetASM-P4 language specification: https://github.com/NetASM/NetASM-python/blob/master/netasm/netasm_v1_1.pdf', 'NetASM: A Low-Level Assembly Language for Packet Processing on Programmable Hardware - https://dl.acm.org/doi/10.1145/3229591.3229596']",1,11_protocol_independent_forwarding,0.95,1
84,Which of the following are true about locally contained applications? Select all that apply.,"a. Locally contained applications can be implemented with regular OpenFlow instructions.
b. A MAC learning switch can be implemented as a locally contained application.
c. Locally contained applications forward packets more slowly than their stateless counterparts.
d. A locally contained application can implement SDN logic without ever requiring a packet to be sent to the controller.
e. Locally contained applications allow the hardware pipeline to make switch-local state modifications.
",,"b,d,e","b,d,e",,"Locally contained applications can implement certain SDN logic entirely within the switch hardware pipeline without requiring packets to be sent to the controller. A MAC learning switch is an example of a locally contained application that can be implemented this way. The hardware pipeline can make local state modifications to enable this. However, locally contained applications cannot be implemented with regular OpenFlow instructions and they do not necessarily forward packets more slowly than stateless applications.","['https://opennetworking.org/wp-content/uploads/2013/02/openflow-switch-v1.4.0.pdf', 'https://www.sdxcentral.com/networking/sdn/definitions/what-is-openflow/', 'https://www.coursera.org/lecture/sdn/lesson-6-1-locally-contained-applications-XAMTi']",1,11_protocol_independent_forwarding,0.9,1
86,What are some examples of optimizations that a compiler could perform on NetASM instructions? Select all that apply.,"a. Preventing bufferbloat for real-time application traffic.
b. Forwarding packets for high-volume flows at higher rates.
c. Composing or decomposing tables to save either on table size or table width.
d. Only instantiating hardware resources (e.g., table entries) for flows that actually have nonzero traffic volume.
e. Reordering instructions so that subsequent tables need not be as large (e.g., not storing state for unmatched packets).
",,"c,d,e","c,d,e",,"A compiler for NetASM instructions could perform optimizations like composing or decomposing tables to optimize table size or width (c), only instantiating hardware resources like table entries for flows that actually have traffic to save resources (d), and reordering instructions so that subsequent tables can be smaller by not storing state for unmatched packets (e). Preventing bufferbloat (a) and forwarding high-volume flows faster (b) are not compiler optimizations but rather runtime behaviors.","['Nick McKeown, Tom Anderson, Hari Balakrishnan, Guru Parulkar, Larry Peterson, Jennifer Rexford, Scott Shenker, and Jonathan Turner. 2008. OpenFlow: enabling innovation in campus networks. SIGCOMM Comput. Commun. Rev. 38, 2 (March 2008), 69–74.', 'Pat Bosshart, Dan Daly, Glen Gibb, Martin Izzard, Nick McKeown, Jennifer Rexford, Cole Schlesinger, Dan Talayco, Amin Vahdat, George Varghese, and David Walker. 2014. P4: programming protocol-independent packet processors. SIGCOMM Comput. Commun. Rev. 44, 3 (July 2014), 87–95.']",1,11_protocol_independent_forwarding,0.9,1
