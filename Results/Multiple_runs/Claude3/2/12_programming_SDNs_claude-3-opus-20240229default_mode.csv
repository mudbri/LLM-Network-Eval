Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
87,Which of the following reasons make programming OpenFlow switches difficult? Select all that apply.,"a. An OpenFlow controller only sees events for packets that the switches do not know how to handle.
b. OpenFlow networks require a single, centralized network controller.
c. Networks often have switches from multiple hardware vendors.
d. OpenFlow switches control switches at a low level of abstraction.
e. Network policies involve many independent tasks that may have conflicting behaviors.
",,"a,d,e","c,e",,"Programming OpenFlow switches can be difficult for a couple reasons:c) Networks often have switches from multiple hardware vendors. This heterogeneity makes it challenging to program switches in a uniform way since different vendors may have varying capabilities and implementations.  e) Network policies typically involve many independent tasks that may exhibit conflicting behaviors. Orchestrating and resolving these conflicts across the various switches in the network adds complexity.The other options are not correct:a) OpenFlow controllers see all packets by default, not just ones the switches don't know how to handle. b) OpenFlow allows for distributed controllers, a centralized controller is not required.d) OpenFlow provides a higher-level flow-based abstraction, not low-level switch control.","['https://www.opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.3.1.pdf', 'https://www.sciencedirect.com/science/article/pii/S1389128613000789']",0,12_programming_SDNs,0.8,1
89,"Suppose that a network operator wants to express a policy that drops all traffic except for traffic from a specific IP prefix (i.e., group of IP addresses).  What problems exist with expressing this policy as a set of OpenFlow rules? Select all that apply.","a. Switches have limited room for flow table entries and cannot store rules for all IP addresses in a prefix by default.
b. The controller may see more than the first packet for a flow that it has already installed.
c. If the controller installs the rules in the wrong order, all traffic might be dropped, instead of allowing the permitted traffic.
d. If the operator starts adding more IP addresses that are permitted to send traffic, performance of the switch might suffer as the number of entries in the switch table grows.
e. Flow table entries can only perform exact matches on IP addresses, so installing rules that operate on groups of IP addresses will take many flow-table entries in the switch.
",,"a,b,c,d","a,d,e",,"There are several issues with expressing a policy to drop all traffic except from a specific IP prefix using OpenFlow rules:a) Switches have limited flow table space and cannot store rules for all individual IP addresses in a prefix by default. d) As more permitted IP addresses are added, the growing number of switch table entries can degrade switch performance.e) Flow table entries only support exact IP address matches, so allowing a group of IPs requires many flow table entries.The other options are not correct because:b) The controller should only see the first packet of a flow after installing a rule for it.c) Rule installation order does not impact traffic dropping if the rules are defined correctly.","['https://www.opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.3.1.pdf', 'https://www.sciencedirect.com/science/article/pii/S1389128613000285']",0,12_programming_SDNs,0.9,1
90,Which of the following have examples of sequential composition? Select all that apply.,"a. Block all port 80 traffic and count the number of packets that are blocked.
b. Load balance traffic based on whether the traffic matches a particular destination IP prefix.
c. Block all traffic except port 80 and count the number of packets that are blocked.
d. Block all traffic except port 80 traffic, and load balance port 80 traffic across three destination IP addresses.
e. Block all traffic except port 80 and count the number of packets that are not blocked.
",,"b,d,e",d,,"Option d is the only choice that demonstrates sequential composition. It involves first blocking all traffic except port 80, and then load balancing the allowed port 80 traffic across three destination IP addresses. This is a sequence of two distinct operations applied to the traffic. The other options either involve parallel composition of policies (a, c, e) or a single policy action (b).","['Software Defined Networking (SDN) course materials covering sequential and parallel composition of policies', 'Understanding of how traffic filtering and load balancing can be combined sequentially']",0,12_programming_SDNs,0.95,1
91,Which of the following have examples of parallel composition? Select all that apply.,"a. Perform load balancing on any traffic that arrives from prefix 130.207.0.0/16 or is destined to port 80.
b. Perform MAC learning on all traffic that is not blocked by a firewall rule.
c. Count all port 80 traffic.
d. Block all traffic whose source IP address is contained in a list of blocked IP addresses.
e. Load balance traffic across multiple destination IP addresses and perform routing to the resulting destination IP addresses.
",,"a,c,d","a,e",,"Parallel composition involves applying multiple policies or actions simultaneously to the same traffic. In choice (a), load balancing is performed on traffic that matches either the source prefix or the destination port, which are two parallel criteria. In choice (e), load balancing and routing are performed in parallel on the same traffic. The other choices describe sequential composition where policies are applied one after the other based on certain conditions.","['https://www.cs.princeton.edu/~jrex/papers/frenetic13.pdf', 'https://opennetworking.org/wp-content/uploads/2013/02/openflow-spec-v1.3.1.pdf']",0,12_programming_SDNs,0.9,1
92,Which of the following is the appropriate Pyretic rule for matching traffic that sends packets from either 10.0.0.1 or 10.0.0.2 to IP address 1.2.3.4?,"a. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
b. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
c. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
d. (match(srcip=10.0.0.1) >> (match(srcip=10.0.0.2) >> mod(dstip=1.2.3.4))
e. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
",,c,c,,"The correct Pyretic rule for matching traffic from either source IP 10.0.0.1 or 10.0.0.2 to destination IP 1.2.3.4 is '(match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)'. The '+' operator performs a parallel composition, matching packets from either source IP. The '>>' operator then performs a sequential composition, modifying the destination IP of the matched packets to 1.2.3.4.","['Pyretic Language Tutorial, https://github.com/frenetic-lang/pyretic/wiki/Language-Tutorial', 'Composing Software Defined Networks, NSDI 2013, https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final232.pdf']",1,12_programming_SDNs,0.95,1
93,Which of the following is the appropiate Pyretic rule for sending traffic from source IP address 10.0.0.1 to destination IP address 10.1.2.3 and traffic from source IP address 10.0.0.2 to destination IP address 10.2.3.4?,"a. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2)  + mod(dstip=10.2.3.4))
b. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4))
c. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) >>mod(dstip=10.2.3.4))
d. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) + mod(dstip=10.2.3.4))
e. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) & (match(srcip=10.0.0.2)  >> mod(dstip=10.2.3.4))
",,b,b,,"The correct Pyretic rule for sending traffic from source IP 10.0.0.1 to destination IP 10.1.2.3 and traffic from source IP 10.0.0.2 to destination IP 10.2.3.4 is option b: (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4)). The >> operator in Pyretic represents sequential composition, meaning the match condition is applied first, followed by the modification action. The + operator represents parallel composition, combining the two traffic flows. Options a and d incorrectly use + instead of >> between match and mod. Options c and e use >> and & operators respectively, which do not correctly combine the two traffic flows in parallel.","['https://github.com/frenetic-lang/pyretic/wiki/Language-Basics', 'https://www.sdxcentral.com/networking/sdn/definitions/what-is-pyretic-sdn-programming-language/']",1,12_programming_SDNs,0.95,1
94,Which of the following might be examples that would use a dynamic policy in Pyretic? Select all that apply.,"a. Check each new traffic flow against a list of permitted and prohibited source IP addresses that may change over time.
b. Drop all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
c. Assign each new traffic flow to a different destination IP address based on a round-robin load balancing policy across servers.
d. Count all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
e. Forward traffic through the network based on shortest paths routing, re-routing traffic appropriately when links or nodes fail.
",,"a,c,e","a,c,e",,"Dynamic policies in Pyretic are those that can change behavior based on network conditions or external events. From the given choices:a. Checking traffic against a changing list of permitted/prohibited IPs would require a dynamic policy to adapt the filtering rules as the list changes over time.c. Round-robin load balancing across servers requires dynamically assigning each new flow to a different destination IP, which is a dynamic policy.  e. Routing based on shortest paths and re-routing when links/nodes fail requires the forwarding policy to dynamically adapt to topology changes, making it a dynamic policy.In contrast, dropping traffic from a fixed prefix (b) or counting traffic from a fixed prefix (d) do not require the policy to change dynamically.","['Pyretic: A Language and Runtime System for Network Virtualization and SDN Programming. J. Reich, C. Monsanto, N. Foster, J. Rexford, and D. Walker. NSDI 2013.', 'Modular SDN Programming with Pyretic. C. Monsanto, J. Reich, N. Foster, J. Rexford, and D. Walker. ;login: 38(5), Oct. 2013.']",1,12_programming_SDNs,0.9,1
