Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
78,What are some of the desired features in future SDN switches that motivate a programmable data plane? Select all that apply.,"a. Reducing energy consumption for custom packet processing.
b. Processing packets at higher rates.
c. A wider range of packet processing primitives.
d. Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel.
e. A configurable packet parser that is not tied to a specific header format.
",,"c,d,e","a,b,c,d,e",,"The desired features in future SDN switches that motivate a programmable data plane include a variety of aspects aimed at improving performance, flexibility, and efficiency. Reducing energy consumption for custom packet processing (a) is important as networks seek to become more environmentally friendly and cost-efficient. Processing packets at higher rates (b) is a constant goal to keep up with increasing bandwidth demands. A wider range of packet processing primitives (c) allows for more sophisticated and varied network functions. Flexible match-action tables (d), such as the ability to compose them in sequence or parallel, provide the versatility needed for complex policy implementations and traffic management. Lastly, a configurable packet parser that is not tied to a specific header format (e) is crucial for supporting a wide range of protocols, including emerging and custom ones, without hardware changes.","['https://www.opennetworking.org/software-defined-standards/overview/', 'https://www.ietf.org/blog/sdn/', 'https://p4.org/']",0,11_protocol_independent_forwarding,0.95,0.8591331511553801
79,Which of the following best describes protocol independence?,"a. The ability to configure a packet parser in hardware that is agnostic to (and not constrained by) the control protocol.
b. The ability to evolve an existing control protocol without breaking interoperability.
c. The ability to run a switch independently from the controller.
d. The ability to support multiple protocols running in parallel on the same hardware.
e. The ability to run a network with both legacy OpenFlow switches and switches that support custom packet processing.
",,a,"a,d",,"Protocol independence refers to the capability of network devices or systems to operate without being tied to a specific communication protocol. Option (a) describes a scenario where the packet parser in hardware is not limited by the control protocol, which aligns with the concept of protocol independence. Option (d) indicates support for multiple protocols simultaneously on the same hardware, which is also a characteristic of protocol independence. Option (b) is more about the evolution of a control protocol rather than protocol independence. Option (c) discusses the operational independence of a switch from a controller, which is not directly related to protocol independence. Option (e) is about interoperability between legacy and modern switch technologies, which might imply some level of protocol independence but is not the best description of the term.","['https://en.wikipedia.org/wiki/Protocol-independent_multicast', 'https://www.sdxcentral.com/networking/sdn/definitions/what-is-software-defined-networking/']",0,11_protocol_independent_forwarding,0.9,0.6397764055494741
81,Which of the following describe functions of the P4 parser? Select all that apply.,"a. Constructing a graph of dependencies between different logical tables.
b. Translating rules to physical tables.
c. Verifying that the description of packet parsing is consistent with the behavior of an existing hardware switch (e.g., a legacy OpenFlow switch).
d. Translating a packet processing specification to a state machine.
e. Mapping logical tables to underlying switch resources.
",,"c,d","a,d",,"The P4 parser is a component of the P4 programming language used for describing how packets are processed by the data plane in a networking device. Specifically, the parser's functions include: (a) Constructing a graph of dependencies between different logical tables, which is part of defining how packets are processed and how different header fields are extracted and used. (d) Translating a packet processing specification to a state machine, which is essential for defining the sequence of operations performed on packet headers as they are parsed. Options (b) and (e) are related to the mapping of high-level policies to specific hardware implementations, which is not the direct role of the parser but rather of the P4 compiler or control plane. Option (c) is not a function of the P4 parser; the parser does not verify consistency with existing hardware but rather defines the desired packet processing behavior.","['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html#sec-parsers', 'https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html#sec-packet-processing']",0,11_protocol_independent_forwarding,0.95,0.9058462624344829
82,"Which of the following best describe the relationship between a language like P4, an assembler like NetASM, and target programmable hardware (e.g., RMT)?","a. P4 is much more amenable to ""cost semantics"" (i.e., figuring out how much a particular operation would cost in terms of power or area) than NetASM.
NetASM and P4 are two examples of high-level programming languages; they are interchangeable.
b. P4 has verifiable semantics, whereas NetASM does not.
c. A language like P4 would ""compile"" to an assembly language like NetASM, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
d. A language like NetASM would ""compile"" to an assembly language like P4, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
",,c,c,,"P4 is a high-level language specifically designed for programming the data plane of network devices, such as switches and routers. It allows the specification of how packets are processed by the hardware. NetASM, on the other hand, is more like an assembly language for network processing, providing a lower-level interface to hardware resources. The typical workflow would involve writing high-level P4 code, which is then compiled down to an intermediate representation like NetASM, which in turn directly corresponds to the resources on the programmable hardware such as the RMT (Reconfigurable Match Tables) architecture. Therefore, the relationship is that P4 code compiles to an assembly language like NetASM, which specifies the resource usage on the hardware.","['https://p4.org/', 'https://www.sdxcentral.com/networking/sdn/definitions/whats-the-difference-between-sdn-and-nfv/', 'https://www.sigcomm.org/sites/default/files/ccr/papers/2014/July/0000000-0000004.pdf']",1,11_protocol_independent_forwarding,0.95,0.9993431806503288
83,Which of the folloiwing instruction types create state elements in NetASM? Select all that apply.,"a. JMP
b. DRP
c. LBL
d. MKT
e. MKR
",,"d,e","c,d,e",,"In NetASM (Network Assembly), which is a low-level instruction set architecture for Software Defined Networking (SDN), the types of instructions that create state elements are those that define labels, tables, and registers. 'LBL' (Label) instruction is used to define a label which is a kind of state as it marks a specific point in the instruction flow. 'MKT' (Make Table) instruction is used to create a match-action table, which is a stateful element in SDN. 'MKR' (Make Register) instruction is used to create a register, which is also a stateful element as it holds state (data). 'JMP' (Jump) is a control flow instruction and 'DRP' (Drop) is an action instruction, neither of which create state elements.","['https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-gibb.pdf', 'https://www.sciencedirect.com/science/article/pii/S1877050916313798']",0,11_protocol_independent_forwarding,0.95,0.5467642079276458
84,Which of the following are true about locally contained applications? Select all that apply.,"a. Locally contained applications can be implemented with regular OpenFlow instructions.
b. A MAC learning switch can be implemented as a locally contained application.
c. Locally contained applications forward packets more slowly than their stateless counterparts.
d. A locally contained application can implement SDN logic without ever requiring a packet to be sent to the controller.
e. Locally contained applications allow the hardware pipeline to make switch-local state modifications.
",,"b,d,e","a,b,d,e",,"Locally contained applications are those that can operate solely within the switch's processing capabilities without requiring intervention from the SDN controller for every packet. They are designed to handle packets locally and can make state modifications in the hardware pipeline. Therefore, they can implement SDN logic without needing to send every packet to the controller for instructions. This includes applications such as a MAC learning switch, which learns the MAC addresses of devices on the network and associates them with the corresponding switch ports, and can be implemented using standard OpenFlow instructions. These applications do not inherently forward packets more slowly than stateless applications; in fact, they can often forward packets more quickly because they do not require round-trip communication with the controller for every decision.","['Open Networking Foundation, ""OpenFlow Switch Specification"", https://opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.0.0.pdf', 'McKeown, Nick et al. ""OpenFlow: Enabling Innovation in Campus Networks"", ACM SIGCOMM Computer Communication Review, https://dl.acm.org/doi/10.1145/1355734.1355746', 'Kreutz, Diego et al. ""Software-Defined Networking: A Comprehensive Survey"", Proceedings of the IEEE, https://ieeexplore.ieee.org/document/6994333']",0,11_protocol_independent_forwarding,0.95,0.995362213228318
86,What are some examples of optimizations that a compiler could perform on NetASM instructions? Select all that apply.,"a. Preventing bufferbloat for real-time application traffic.
b. Forwarding packets for high-volume flows at higher rates.
c. Composing or decomposing tables to save either on table size or table width.
d. Only instantiating hardware resources (e.g., table entries) for flows that actually have nonzero traffic volume.
e. Reordering instructions so that subsequent tables need not be as large (e.g., not storing state for unmatched packets).
",,"c,d,e","c,d,e",,"Compiler optimizations for NetASM instructions generally involve improving the efficiency of how instructions and tables are managed, rather than dealing with traffic management directly. Option 'c' refers to the optimization of table composition or decomposition to save on resources, which is a typical compiler optimization technique. Option 'd' discusses instantiating hardware resources only for active flows, which is a form of resource optimization to avoid wasting space on unused entries. Option 'e' involves reordering instructions to minimize the required state to be stored, which is another form of compiler optimization to reduce resource usage. Options 'a' and 'b', on the other hand, are more related to network traffic management policies rather than compiler optimizations.","['https://en.wikipedia.org/wiki/Software-defined_networking', 'https://en.wikipedia.org/wiki/Compiler_optimization']",1,11_protocol_independent_forwarding,0.95,0.9998808186163355
