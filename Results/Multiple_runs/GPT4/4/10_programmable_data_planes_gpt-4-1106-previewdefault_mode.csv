Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
113,"Which are reasonable approaches for designing a fast, scalable, programmable data plane? Select all that apply.","a. Make hardware routers more programmable with custom OpenFlow chips.
b. Make software routers faster by reducing the need to copy packets from the kernel into user space.
c. Send all traffic through software switches running in user space.
d. Make software routers faster by distributing software routers across clusters.
e. Make software routers faster by amortizing packet-processing costs across batches of packets.
",,"a,b,d,e","a,b,d,e",,"The design of a fast, scalable, programmable data plane can be approached in several ways. Custom OpenFlow chips can be used in hardware routers to increase their programmability (a). Software routers can be made faster by reducing the overhead associated with copying packets from the kernel space to the user space (b), which is a common performance bottleneck. Distributing software routers across clusters can help in scaling the data plane by leveraging parallel processing and high availability (d). Amortizing packet-processing costs across batches of packets (e) is another technique that can lead to increased efficiency by reducing per-packet processing overhead and taking advantage of modern CPU's processing capabilities. Sending all traffic through software switches running in user space (c) is not necessarily a reasonable approach for designing a scalable data plane, as it could introduce significant performance bottlenecks and does not inherently provide a means for scaling.","['https://www.opennetworking.org/wp-content/uploads/2013/02/cs244-spring13-openflow.pdf', 'https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-katta.pdf', 'https://www.sigcomm.org/sites/default/files/ccr/papers/2013/July/2500098-2500100.pdf']",1,10_programmable_data_planes,0.95,0.9773709347026224
114,What are functions that are commonly performed by a programmable data plane? Select all that apply.,"a. Performing deep packet inspection
b. Forwarding
c. Specifying access control policies
d. Shaping traffic
e. Computing routes
",,"a,b,d","a,b,c,d",,"A programmable data plane offers various functions that go beyond the traditional forwarding of packets based on static rules. These functions include: (a) Performing deep packet inspection, which allows the data plane to analyze packet content beyond just header information for security and application-aware networking; (b) Forwarding, which is a fundamental role of the data plane to move packets from one point to another based on rules; (c) Specifying access control policies, which can be dynamically implemented and updated in the data plane to control network access and traffic; (d) Shaping traffic, which involves managing the flow of packets to ensure quality of service and adherence to network policies. The computation of routes (e) is generally considered a control plane function, where routing protocols and algorithms determine the paths that traffic should take through the network.","['https://www.sdxcentral.com/networking/sdn/definitions/whats-programmable-data-plane/', 'https://www.networkworld.com/article/3254575/what-is-a-software-defined-data-plane.html']",0,10_programmable_data_planes,0.95,0.9998338664060641
115,Which of the following functions might be performed by a Click element? Select all that apply.,"a. Reading a packet from a network device
b. Dropping packets
c. Counting packets
d. Classifying packets into different priority queues
e. Computing shortest paths routes between two routers
",,"a,b,c,d","a,b,c,d",,"Click is a modular software router framework that allows for flexible and programmable packet processing. The functions that might be performed by a Click element include: (a) Reading a packet from a network device, as elements are designed to handle packet input and output; (b) Dropping packets, which is a basic function in packet processing for managing traffic and ensuring security; (c) Counting packets, which is essential for monitoring and managing network traffic; (d) Classifying packets into different priority queues, which is a function related to traffic management and Quality of Service (QoS). However, (e) Computing shortest paths between two routers is typically a function of routing protocols and not a direct function of individual Click elements.","['https://click.cs.columbia.edu/', 'https://en.wikipedia.org/wiki/Click_modular_router']",1,10_programmable_data_planes,0.95,0.9999954854512405
116,Which of the following are true about programmable data planes in Click? Select all that apply.,"a. Click elements cannot perform common data plane operations such as TTL decrement or checksum computations.
b. Data-plane processing in Click is limited to a fixed set of elements provided by the software.
c. Click elements can be composed to perform complex functions, such as the forwarding at an IP router.
d. Click configuration is a simplified version of Python.
e. Click elements can be composed to perform complex network-wide functions, such as shortest paths or BGP routing.
",,c,"c,e",,"Click is a modular software router that allows for the composition of packet-processing elements. These elements can be connected to form more complex functions. Option c is correct because Click elements can indeed be composed to perform complex functions like those of an IP router, including forwarding. Option e is also correct as Click's modular design allows for the creation of elements that can handle complex network-wide functions such as implementing shortest path computations or BGP routing. Option a is incorrect because Click elements can perform common data plane operations, including TTL decrement and checksum computations. Option b is incorrect because although Click comes with a rich set of pre-defined elements, it also allows for the creation of custom elements to extend its functionality. Option d is incorrect because Click's configuration language is not a simplified version of Python; it is a domain-specific language designed for describing how packets should be processed.","['https://click.csail.mit.edu/', 'https://en.wikipedia.org/wiki/Click_modular_router']",0,10_programmable_data_planes,0.95,0.871586150534791
117,Why does a RouteBricks server assign one core per queue?,"a. Having multiple cores accessing the same queue would require each core to perform only one function in the packet processing pipeline, which is inefficient.
b. Having multiple cores accessing the same queue would require locking to prevent concurrent memory accesses, slowing packet forwarding performance.
c. Having multiple cores accessing the same queue might create the possibility that there is a queue that is not served by any cores.
d. Cores have heterogeneous performance, and packets are different sizes, so it makes sense to assign less powerful cores to queues that have smaller packets.
",,b,b,,"RouteBricks is a software-based router that aims to achieve high performance by parallelizing the packet processing over multiple cores in a system. When multiple cores access the same queue, there is a need for synchronization mechanisms like locking to prevent concurrent memory accesses and maintain the integrity of the queue. Such locking can introduce significant overhead and slow down packet forwarding, as cores may have to wait for each other to access and modify the queue. This is why a RouteBricks server assigns one core per queue, to avoid the need for locking and to maximize packet forwarding performance.","[""Anwer, Muhammad, et al. 'RouteBricks: Exploiting Parallelism to Scale Software Routers.' Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles, 2009, pp. 151–164."", ""Dobrescu, Mihai, et al. 'Understanding the Performance of Software Routers.' Proceedings of the 1st ACM Workshop on Research on Enterprise Networking, 2009, pp. 1–8.""]",1,10_programmable_data_planes,0.95,0.9999895549275502
118,What are some tricks commonly employed in software to accelerate packet forwarding? Select all that apply.,"a. Ethernet GRE tunnels
b. Large packet buffers that hold multiple packets that can be read with a single read
c. Forwarding smaller packets before larger packets
d. Avoiding lookups on the software bridge between virtual interfaces and physical interfaces
e. Batch processing
",,"a,b,d,e","b,c,d,e",,"To accelerate packet forwarding in software, several techniques are commonly employed: b) Large packet buffers can improve efficiency by allowing multiple packets to be read with a single read operation, reducing the per-packet processing overhead. c) Forwarding smaller packets before larger packets can reduce the average latency, as smaller packets will spend less time in queues. d) Avoiding lookups on the software bridge between virtual interfaces and physical interfaces can reduce processing time by minimizing the overhead of each packet's traversal through the network stack. e) Batch processing involves processing multiple packets at once, which can reduce the per-packet processing cost and improve overall throughput. Option a) Ethernet GRE tunnels are a method for encapsulating packets for tunneling, not specifically a trick to accelerate packet forwarding.","['https://en.wikipedia.org/wiki/Network_packet', 'https://en.wikipedia.org/wiki/Packet_buffer', 'https://en.wikipedia.org/wiki/Generic_Routing_Encapsulation']",0,10_programmable_data_planes,0.95,0.5446450050125279
119,What are some of the problems with current OpenFlow hardware that motivated a custom OpenFlow chip design? Select all that apply.,"a. Current hardware makes it difficult to implement multiple match action stages, and to repurpose TCAM and SRAM across multiple match-action stages.
b. Current hardware cannot forward traffic at line rates.
c. The current OpenFlow protocol depends on the constraints of conventional switching chips.
d. Current hardware cannot support OpenFlow 1.0 match-action primitives.
e. Current hardware is difficult to repurpose in the field.
",,"a,c,e","a,c,e",,"The motivation for a custom OpenFlow chip design is often related to limitations in flexibility, performance, and the ability to adapt to new requirements. Option (a) is correct because current hardware often has limitations in implementing multiple match-action stages flexibly, and reusing TCAM (Ternary Content Addressable Memory) and SRAM (Static Random-Access Memory) across these stages can be challenging. Option (c) is correct because the OpenFlow protocol's evolution can be constrained by the capabilities of conventional switching chips, which were not originally designed with OpenFlow in mind. Option (e) is correct as repurposing existing hardware to support new networking functions or protocols in the field can be difficult due to the fixed function nature of most networking hardware. Option (b) is incorrect because many current hardware platforms can forward traffic at line rates, especially in high-performance switches. Option (d) is incorrect because OpenFlow 1.0 is relatively old, and most current hardware that supports OpenFlow can support the match-action primitives defined in OpenFlow 1.0.","['https://www.opennetworking.org/wp-content/uploads/2013/02/cs-nos-ovs-1.pdf', 'https://www.sdxcentral.com/networking/sdn/definitions/inside-sdn-architecture/', 'https://www.sdxcentral.com/networking/sdn/definitions/what-the-definition-of-openflow/']",1,10_programmable_data_planes,0.95,0.9996255730595694
120,"Which of the following are motivations for SwitchBlade, which supports composition of pre-synthesized hardware data plane modules on an FPGA? Select all that apply.","a. Most data plane protocols involve composing only a limited number of data-plane actions.
b. Experimental data planes may need to operate in parallel with production data planes.
c. Programming in Verilog is difficult.
d. FPGAs are lower-cost and consume less power than conventional ASICs or OpenFlow switching chips.
e. Programming in C is difficult.
",,"a,b,c","a,b,c",,"SwitchBlade is motivated by the need for a flexible and programmable network data plane that allows for the composition of different data plane functions. The motivations include: a) Most data plane protocols do indeed involve composing a limited number of data-plane actions, which makes the modular approach feasible and efficient. b) Experimental data planes often need to be tested and run in parallel with production data planes without affecting the production traffic, which requires an adaptable hardware platform. c) Programming FPGAs using hardware description languages like Verilog is known to be difficult and time-consuming compared to higher-level programming abstractions, hence the need for a system that simplifies this process. Meanwhile, d) is incorrect because FPGAs generally are not lower-cost nor do they consume less power than ASICs or specialized OpenFlow switching chips in the context of networking hardware. They are chosen for their flexibility, not for cost or power efficiency. e) is irrelevant to the context of hardware data plane modules, as the difficulty of programming in C is not a motivation for a hardware-focused solution like SwitchBlade.","['https://dl.acm.org/doi/abs/10.1145/2342441.2342449', 'https://ieeexplore.ieee.org/abstract/document/6133201', 'https://www.usenix.org/conference/nsdi12/technical-sessions/presentation/anzig']",1,10_programmable_data_planes,0.9,0.868789418786306
