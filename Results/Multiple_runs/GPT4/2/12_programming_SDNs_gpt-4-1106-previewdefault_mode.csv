Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
87,Which of the following reasons make programming OpenFlow switches difficult? Select all that apply.,"a. An OpenFlow controller only sees events for packets that the switches do not know how to handle.
b. OpenFlow networks require a single, centralized network controller.
c. Networks often have switches from multiple hardware vendors.
d. OpenFlow switches control switches at a low level of abstraction.
e. Network policies involve many independent tasks that may have conflicting behaviors.
",,"a,d,e","a,c,d,e",,"Programming OpenFlow switches can be challenging for several reasons. a) An OpenFlow controller indeed only sees events for packets that the switches do not know how to handle, which means that the controller must be programmed to handle a variety of scenarios and ensure that the switch is properly configured for all possible packet types. c) Networks often have switches from multiple hardware vendors, which can lead to compatibility issues or differences in implementation that can make programming more complex. d) OpenFlow switches operate at a low level of abstraction, meaning that programmers need to deal with the intricacies of switch operations and protocols, which can be less intuitive than higher-level programming abstractions. e) Network policies can involve many independent tasks that may have conflicting behaviors, making it difficult to program switches in a way that all policies are enforced correctly without unintended interactions. Option b is incorrect because OpenFlow does not require a single, centralized network controller; it can work with distributed controllers as well.","['https://www.opennetworking.org/software-defined-standards/overview/', 'https://www.sdxcentral.com/networking/sdn/definitions/what-the-definition-of-openflow/', 'https://en.wikipedia.org/wiki/OpenFlow']",0,12_programming_SDNs,0.95,0.9256114676811852
89,"Suppose that a network operator wants to express a policy that drops all traffic except for traffic from a specific IP prefix (i.e., group of IP addresses).  What problems exist with expressing this policy as a set of OpenFlow rules? Select all that apply.","a. Switches have limited room for flow table entries and cannot store rules for all IP addresses in a prefix by default.
b. The controller may see more than the first packet for a flow that it has already installed.
c. If the controller installs the rules in the wrong order, all traffic might be dropped, instead of allowing the permitted traffic.
d. If the operator starts adding more IP addresses that are permitted to send traffic, performance of the switch might suffer as the number of entries in the switch table grows.
e. Flow table entries can only perform exact matches on IP addresses, so installing rules that operate on groups of IP addresses will take many flow-table entries in the switch.
",,"a,b,c,d","a,c,d,e",,"a. Switches indeed have limited space for flow table entries, which means they cannot accommodate an entry for every individual IP address within a large prefix if the rules were to be set up for each IP address individually.
c. If the rules are not installed in the correct order, specifically if the drop-all rule is installed before the allow rule for the specific IP prefix, it could lead to all traffic being dropped unintentionally.
d. As more IP addresses are allowed, the switch's performance could degrade if it leads to a linear increase in the number of flow table entries, which could consume more resources and processing time for each packet.
e. OpenFlow switches can match on IP prefixes using mask operations, not just exact matches. However, expressing policies for groups of IP addresses may still require multiple entries if the policy cannot be expressed with a single prefix match, leading to the potential use of many flow table entries.
Option b is not a problem related to expressing the policy itself but rather a potential issue with the controller's operation after the policy has been implemented.","['https://www.opennetworking.org/wp-content/uploads/2013/02/openflow-spec-v1.3.0.pdf', 'https://en.wikipedia.org/wiki/Software-defined_networking']",0,12_programming_SDNs,0.95,0.9810219103673736
90,Which of the following have examples of sequential composition? Select all that apply.,"a. Block all port 80 traffic and count the number of packets that are blocked.
b. Load balance traffic based on whether the traffic matches a particular destination IP prefix.
c. Block all traffic except port 80 and count the number of packets that are blocked.
d. Block all traffic except port 80 traffic, and load balance port 80 traffic across three destination IP addresses.
e. Block all traffic except port 80 and count the number of packets that are not blocked.
",,"b,d,e","a,c,e",,"Sequential composition in the context of networking policies refers to the application of multiple policy actions in a specific order. For instance, one action may occur after another, such as blocking traffic first and then counting the packets that were blocked. Options a, c, and e describe scenarios where two actions are taken in sequence: blocking certain traffic and then counting the packets that meet the block condition (either being blocked or allowed through). Option b describes a conditional action (load balancing based on a match) but not a sequence of actions. Option d combines two actions (blocking and load balancing) but does not involve counting or a clear sequential composition of actions as the others do.","['https://en.wikipedia.org/wiki/Software-defined_networking', 'https://www.sciencedirect.com/topics/computer-science/sequential-composition']",0,12_programming_SDNs,0.9,0.9838652130008398
91,Which of the following have examples of parallel composition? Select all that apply.,"a. Perform load balancing on any traffic that arrives from prefix 130.207.0.0/16 or is destined to port 80.
b. Perform MAC learning on all traffic that is not blocked by a firewall rule.
c. Count all port 80 traffic.
d. Block all traffic whose source IP address is contained in a list of blocked IP addresses.
e. Load balance traffic across multiple destination IP addresses and perform routing to the resulting destination IP addresses.
",,"a,c,d","a,e",,"Parallel composition in networking refers to performing multiple actions independently and simultaneously on network traffic. Option 'a' is an example of parallel composition because it involves performing load balancing on traffic based on two different criteria: the traffic's source prefix and the destination port. This implies that the system is handling two separate streams of traffic (one identified by source prefix and the other by destination port) and applying the same action (load balancing) to both streams at the same time. Option 'e' is also an example of parallel composition as it describes two actions: load balancing traffic across multiple destination IP addresses and then routing to the resulting IP addresses, which can be done simultaneously. The other options describe actions that are conditional or singular in nature and do not necessarily imply parallel processing.","['https://en.wikipedia.org/wiki/Software-defined_networking', 'https://www.sdxcentral.com/networking/sdn/definitions/what-the-definition-of-software-defined-networking-sdn/']",0,12_programming_SDNs,0.95,0.8673459432181398
92,Which of the following is the appropriate Pyretic rule for matching traffic that sends packets from either 10.0.0.1 or 10.0.0.2 to IP address 1.2.3.4?,"a. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
b. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
c. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
d. (match(srcip=10.0.0.1) >> (match(srcip=10.0.0.2) >> mod(dstip=1.2.3.4))
e. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
",,c,c,,"In Pyretic, the '+' operator is used to denote the logical OR operation, and the '>>' operator is used to denote the sequence or logical AND operation. To match traffic from either 10.0.0.1 or 10.0.0.2, we should use the '+' operator between the two match conditions. After matching the source IP addresses, we want to apply a modification to the destination IP address, which is done using the 'mod' function with the '>>' operator. Therefore, the correct rule is to first combine the matches for both source IPs using '+', and then apply the 'mod' operation using '>>'.","['https://frenetic-lang.org/pyretic/', 'https://openflow.stanford.edu/display/ONL/POX+Wiki#POXWiki-Composingpolicies']",1,12_programming_SDNs,0.95,0.8039996541218236
93,Which of the following is the appropiate Pyretic rule for sending traffic from source IP address 10.0.0.1 to destination IP address 10.1.2.3 and traffic from source IP address 10.0.0.2 to destination IP address 10.2.3.4?,"a. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2)  + mod(dstip=10.2.3.4))
b. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4))
c. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) >>mod(dstip=10.2.3.4))
d. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) + mod(dstip=10.2.3.4))
e. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) & (match(srcip=10.0.0.2)  >> mod(dstip=10.2.3.4))
",,b,b,,"In Pyretic, the 'match' function is used to specify the match conditions for network traffic, and the 'mod' function is used to modify packet fields. The '>>' operator is used to denote the composition of policies, where traffic that matches the first policy is then processed by the second policy. The '+' operator is used to denote the parallel composition of policies, where both policies are applied independently. The correct rule for sending traffic from one source IP to a destination IP and another set of traffic from a different source IP to another destination IP would use the parallel composition of two composed policies. Therefore, the correct answer is (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4)), as it specifies the correct matching and modification for each flow and uses the '+' operator to apply both policies independently.","['https://openflow.stanford.edu/display/ONL/Pyretic+Language+Overview', 'http://frenetic-lang.org/pyretic/']",1,12_programming_SDNs,0.95,0.9937585204625377
94,Which of the following might be examples that would use a dynamic policy in Pyretic? Select all that apply.,"a. Check each new traffic flow against a list of permitted and prohibited source IP addresses that may change over time.
b. Drop all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
c. Assign each new traffic flow to a different destination IP address based on a round-robin load balancing policy across servers.
d. Count all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
e. Forward traffic through the network based on shortest paths routing, re-routing traffic appropriately when links or nodes fail.
",,"a,c,e","a,c,e",,"Dynamic policies in Pyretic are those that can change over time or in response to network conditions. Choice a involves checking against a list that may change, indicating a dynamic policy. Choice c involves load balancing, which is inherently dynamic as it assigns traffic flows to different servers possibly in a round-robin fashion. Choice e involves adapting to network changes such as link or node failures, which is a dynamic response to network conditions. Choices b and d describe static policies that do not change over time or in response to network conditions.","['https://www.cs.cornell.edu/projects/bigreddata/pyretic/', 'https://www.sciencedirect.com/science/article/pii/S1877050915003811']",1,12_programming_SDNs,0.95,0.9999902405279241
