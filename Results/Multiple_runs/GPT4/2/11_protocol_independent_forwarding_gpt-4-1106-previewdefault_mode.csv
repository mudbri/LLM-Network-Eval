Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
78,What are some of the desired features in future SDN switches that motivate a programmable data plane? Select all that apply.,"a. Reducing energy consumption for custom packet processing.
b. Processing packets at higher rates.
c. A wider range of packet processing primitives.
d. Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel.
e. A configurable packet parser that is not tied to a specific header format.
",,"c,d,e","a,b,c,d,e",,"Software Defined Networking (SDN) aims to provide a more flexible and programmable approach to managing network traffic. The desired features in future SDN switches that motivate a programmable data plane include: a) Reducing energy consumption for custom packet processing - as custom processing can be more efficient; b) Processing packets at higher rates - programmability can lead to optimizations that process packets faster; c) A wider range of packet processing primitives - this allows for more complex operations and supports a variety of network functions; d) Flexible match-action tables, such as the ability to compose multiple match-action tables in sequence or in parallel - this flexibility can enable more complex decision-making and flow control; e) A configurable packet parser that is not tied to a specific header format - this allows the switch to handle a variety of protocols and adapt to new ones more easily. All these features contribute to a more adaptable, efficient, and future-proof network infrastructure.","['https://www.opennetworking.org/software-defined-standards/overview/', 'https://www.ietf.org/blog/sdn-open-programmable-networks/', 'https://www.sigcomm.org/sites/default/files/ccr/papers/2014/August/2619239-2626296.pdf']",0,11_protocol_independent_forwarding,0.95,0.8309699312497673
79,Which of the following best describes protocol independence?,"a. The ability to configure a packet parser in hardware that is agnostic to (and not constrained by) the control protocol.
b. The ability to evolve an existing control protocol without breaking interoperability.
c. The ability to run a switch independently from the controller.
d. The ability to support multiple protocols running in parallel on the same hardware.
e. The ability to run a network with both legacy OpenFlow switches and switches that support custom packet processing.
",,a,"a,d",,"Protocol independence refers to the capability of network devices or systems to operate without being tied to a specific communication protocol. Option (a) describes a scenario where the packet parser can understand and process packets regardless of the control protocol, which aligns with the concept of protocol independence. Option (d) describes the ability to support multiple protocols simultaneously, which is another aspect of protocol independence, where the hardware does not favor one protocol over another. Options (b), (c), and (e) are not directly related to the core concept of protocol independence.","['https://en.wikipedia.org/wiki/Software-defined_networking', 'https://www.opennetworking.org/software-defined-standards/overview/']",0,11_protocol_independent_forwarding,0.9,0.6505343115466138
81,Which of the following describe functions of the P4 parser? Select all that apply.,"a. Constructing a graph of dependencies between different logical tables.
b. Translating rules to physical tables.
c. Verifying that the description of packet parsing is consistent with the behavior of an existing hardware switch (e.g., a legacy OpenFlow switch).
d. Translating a packet processing specification to a state machine.
e. Mapping logical tables to underlying switch resources.
",,"c,d","a,d",,"The P4 parser is a component of the P4 programming language, which is used to describe how packets are processed by the data plane of a network switch or router. The parser in P4 is responsible for defining how to extract header fields from incoming packets and how to structure the parsing process. The functions of the P4 parser include: (a) Constructing a graph of dependencies between different logical tables, which is part of the P4 program's specification of how packets should be processed, and (d) Translating a packet processing specification to a state machine, which is necessary to define the sequence of operations for parsing packet headers. Options (b) and (e) are related to the control plane's responsibility to implement the P4 program's rules on the physical hardware, which is not a function of the parser itself. Option (c) is not a typical function of the P4 parser, as the P4 language is designed to be platform-independent and not necessarily to verify the consistency with an existing hardware switch's behavior.","['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html', 'https://p4.org/p4/what-is-p4.html']",0,11_protocol_independent_forwarding,0.95,0.907290730985763
82,"Which of the following best describe the relationship between a language like P4, an assembler like NetASM, and target programmable hardware (e.g., RMT)?","a. P4 is much more amenable to ""cost semantics"" (i.e., figuring out how much a particular operation would cost in terms of power or area) than NetASM.
NetASM and P4 are two examples of high-level programming languages; they are interchangeable.
b. P4 has verifiable semantics, whereas NetASM does not.
c. A language like P4 would ""compile"" to an assembly language like NetASM, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
d. A language like NetASM would ""compile"" to an assembly language like P4, which would then specify a one-to-one relationship with resources on the target forwarding hardware.
",,c,c,,"P4 is a high-level language designed for programming protocol-independent packet processors. NetASM is a low-level assembly-like language that provides a one-to-one mapping to the resources on the target hardware. The relationship between a high-level language like P4 and an assembly language like NetASM is similar to that between high-level programming languages and assembly languages in general computing. The high-level language (P4) would be compiled down to an assembly language (NetASM), which in turn would be closely tied to the resources on the programmable hardware (e.g., RMT, Reconfigurable Match Tables). This process allows for the high-level language to be hardware-agnostic, while the assembly language deals with the specifics of the hardware implementation.","['https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html', 'Bosshart, P., Gibb, G., Kim, H. S., Varghese, G., McKeown, N., Izzard, M., ... & Horowitz, M. (2013, August). Forwarding metamorphosis: Fast programmable match-action processing in hardware for SDN. In ACM SIGCOMM Computer Communication Review (Vol. 43, No. 4, pp. 99-110).']",1,11_protocol_independent_forwarding,0.95,0.999266640939299
83,Which of the folloiwing instruction types create state elements in NetASM? Select all that apply.,"a. JMP
b. DRP
c. LBL
d. MKT
e. MKR
",,"d,e","c,d,e",,"In NetASM (Network Assembly), which is a low-level instruction set architecture for Software Defined Networking (SDN), the types of instructions that create state elements are those that define labels, tables, and registers. 'LBL' (Label) instruction is used to define a label which is a type of state as it marks a location in the instruction sequence. 'MKT' (Make Table) instruction is used to create a new table, which is a stateful element that stores flow entries. 'MKR' (Make Register) instruction creates a new register, which is also a stateful element that stores data.","['https://www.opennetworking.org/wp-content/uploads/2014/10/cs244-spring15-netasm.pdf', 'https://www.cs.princeton.edu/courses/archive/fall16/cos561/papers/NetASM15.pdf']",0,11_protocol_independent_forwarding,0.95,0.5467642079276458
84,Which of the following are true about locally contained applications? Select all that apply.,"a. Locally contained applications can be implemented with regular OpenFlow instructions.
b. A MAC learning switch can be implemented as a locally contained application.
c. Locally contained applications forward packets more slowly than their stateless counterparts.
d. A locally contained application can implement SDN logic without ever requiring a packet to be sent to the controller.
e. Locally contained applications allow the hardware pipeline to make switch-local state modifications.
",,"b,d,e","a,b,d,e",,"Locally contained applications are those that can operate within the switch itself without necessarily requiring interaction with the controller for every packet. They can be implemented using OpenFlow instructions (a), which allow the switch to handle packets according to predefined rules. A MAC learning switch is a classic example of a locally contained application (b), as it learns the source MAC addresses of packets and associates them with switch ports without needing to consult the controller after the initial learning process. Locally contained applications can implement SDN logic such as packet-forwarding decisions based on the state that is maintained locally on the switch (d). This can be done without sending packets to the controller once the appropriate rules are in place. They also allow the hardware pipeline to make switch-local state modifications (e), which can be useful for functions like maintaining counters or updating tables. The statement that locally contained applications forward packets more slowly than their stateless counterparts (c) is generally not true; in fact, by avoiding the need to communicate with the controller for every decision, they can often forward packets more quickly.","['https://www.opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.4.0.pdf', 'https://www.sdxcentral.com/networking/sdn/definitions/what-is-software-defined-networking-sdn/']",0,11_protocol_independent_forwarding,0.95,0.9920454038896308
86,What are some examples of optimizations that a compiler could perform on NetASM instructions? Select all that apply.,"a. Preventing bufferbloat for real-time application traffic.
b. Forwarding packets for high-volume flows at higher rates.
c. Composing or decomposing tables to save either on table size or table width.
d. Only instantiating hardware resources (e.g., table entries) for flows that actually have nonzero traffic volume.
e. Reordering instructions so that subsequent tables need not be as large (e.g., not storing state for unmatched packets).
",,"c,d,e","c,d,e",,"Compiler optimizations for NetASM instructions generally involve improving the efficiency of how instructions and resources are used within the network device. These optimizations focus on the internal operation of packet processing rather than external traffic management or flow control. Therefore, options 'a' and 'b' are not relevant to compiler optimizations for NetASM instructions. Option 'a' is related to network congestion management, and option 'b' is about traffic engineering rather than compiler optimizations. Options 'c', 'd', and 'e' are examples of compiler optimizations:","['https://www.opennetworking.org/software-defined-standards/related-standards/netasm/', 'https://dl.acm.org/doi/10.1145/2934872.2934886']",1,11_protocol_independent_forwarding,0.95,0.9999001274962606
