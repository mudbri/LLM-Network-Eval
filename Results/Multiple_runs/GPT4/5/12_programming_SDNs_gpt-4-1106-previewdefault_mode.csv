Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
87,Which of the following reasons make programming OpenFlow switches difficult? Select all that apply.,"a. An OpenFlow controller only sees events for packets that the switches do not know how to handle.
b. OpenFlow networks require a single, centralized network controller.
c. Networks often have switches from multiple hardware vendors.
d. OpenFlow switches control switches at a low level of abstraction.
e. Network policies involve many independent tasks that may have conflicting behaviors.
",,"a,d,e","a,c,e",,"Programming OpenFlow switches can be challenging for several reasons. Option 'a' is correct because the OpenFlow controller typically only sees packet-in events for packets that do not match any existing flow entries in the switch, which means that the programmer must handle these cases explicitly. Option 'c' is also correct because having switches from multiple hardware vendors can introduce complexity due to potential differences in capabilities and performance characteristics, which can make it difficult to program a homogeneous network behavior. Option 'e' is correct because network policies often consist of many independent tasks, and ensuring that these tasks do not conflict with one another can be a complex programming challenge. Option 'b' is incorrect because OpenFlow does not inherently require a single, centralized controller; it can work with multiple controllers or in a distributed controller setup. Option 'd' is incorrect because OpenFlow actually provides a higher level of abstraction by allowing the controller to program the switches using flow table entries, rather than dealing with low-level hardware specifics.","['Open Networking Foundation. (n.d.). OpenFlow. https://www.opennetworking.org/sdn-resources/openflow', 'McKeown, N., et al. (2008). OpenFlow: Enabling Innovation in Campus Networks. ACM SIGCOMM Computer Communication Review, 38(2), 69-74. https://doi.org/10.1145/1355734.1355746', 'Sherwood, R., et al. (2009). FlowVisor: A Network Virtualization Layer. OpenFlow Switch Consortium, Tech. Rep. https://openflow.stanford.edu/display/DOCS/FlowVisor']",0,12_programming_SDNs,0.95,0.5508597160639538
89,"Suppose that a network operator wants to express a policy that drops all traffic except for traffic from a specific IP prefix (i.e., group of IP addresses).  What problems exist with expressing this policy as a set of OpenFlow rules? Select all that apply.","a. Switches have limited room for flow table entries and cannot store rules for all IP addresses in a prefix by default.
b. The controller may see more than the first packet for a flow that it has already installed.
c. If the controller installs the rules in the wrong order, all traffic might be dropped, instead of allowing the permitted traffic.
d. If the operator starts adding more IP addresses that are permitted to send traffic, performance of the switch might suffer as the number of entries in the switch table grows.
e. Flow table entries can only perform exact matches on IP addresses, so installing rules that operate on groups of IP addresses will take many flow-table entries in the switch.
",,"a,b,c,d","a,c,d",,"a. Switches do indeed have limited room for flow table entries, and representing a large IP prefix by individual IP addresses would be impractical and could easily exceed the capacity of a switch's flow table. Hence, this is a valid problem when expressing the policy as a set of OpenFlow rules.

b. This choice is incorrect because the controller seeing more than the first packet for a flow it has already installed is not a problem related to expressing the policy. This could occur due to various reasons, but it is not inherently problematic with the policy expression itself.

c. If the controller installs the rules in the incorrect order, such as placing a 'drop all traffic' rule before the 'allow' rule for the specific IP prefix, it could result in all traffic being dropped. The order of rule installation is crucial in OpenFlow to ensure the correct policy is implemented.

d. Adding more IP addresses to the whitelist can indeed cause performance issues as the switch's flow table grows. Each new entry consumes resources and the switch's performance could degrade as the table becomes larger and more complex to search through.

e. This choice is incorrect because OpenFlow does support mask-based matching, which would allow the creation of flow table entries that match on groups of IP addresses rather than just exact matches. Therefore, it is possible to express rules that operate on IP prefixes without needing an entry for each individual IP address.","['https://www.opennetworking.org/wp-content/uploads/2014/10/openflow-spec-v1.3.0.pdf', 'https://en.wikipedia.org/wiki/Software-defined_networking']",0,12_programming_SDNs,0.95,0.9897928056909285
90,Which of the following have examples of sequential composition? Select all that apply.,"a. Block all port 80 traffic and count the number of packets that are blocked.
b. Load balance traffic based on whether the traffic matches a particular destination IP prefix.
c. Block all traffic except port 80 and count the number of packets that are blocked.
d. Block all traffic except port 80 traffic, and load balance port 80 traffic across three destination IP addresses.
e. Block all traffic except port 80 and count the number of packets that are not blocked.
",,"b,d,e","a,c,e",,"Sequential composition in the context of Software Defined Networking (SDN) refers to applying multiple network policies or functions in a sequence. Option (a) represents sequential composition because it involves first blocking all port 80 traffic and then counting the packets that are blocked, which is a sequence of two actions. Option (c) is also sequential because it blocks all traffic except port 80 and then counts the number of packets that are blocked, again a sequence of two actions. Option (e) similarly involves a sequence of actions: allowing port 80 traffic and then counting the packets that are not blocked. Options (b) and (d) do not clearly indicate a sequence of actions but rather a single action (load balancing) that is conditional on a match (traffic pattern or port), hence they do not represent sequential composition.","['https://en.wikipedia.org/wiki/Software-defined_networking', 'https://www.sciencedirect.com/topics/computer-science/sequential-composition']",0,12_programming_SDNs,0.95,0.9982484627249395
91,Which of the following have examples of parallel composition? Select all that apply.,"a. Perform load balancing on any traffic that arrives from prefix 130.207.0.0/16 or is destined to port 80.
b. Perform MAC learning on all traffic that is not blocked by a firewall rule.
c. Count all port 80 traffic.
d. Block all traffic whose source IP address is contained in a list of blocked IP addresses.
e. Load balance traffic across multiple destination IP addresses and perform routing to the resulting destination IP addresses.
",,"a,c,d","a,e",,"Parallel composition in networking refers to performing multiple actions or applying multiple policies on network traffic simultaneously or in parallel. Option 'a' suggests performing load balancing based on two independent criteria (source prefix and destination port), which implies parallel processing of policies. Option 'e' explicitly mentions load balancing traffic across multiple destinations and then performing routing, which is another example of applying multiple actions in parallel. Options 'b', 'c', and 'd' describe singular actions or policies being applied and do not inherently suggest parallel composition.","['https://www.sdxcentral.com/networking/sdn/definitions/what-the-definition-of-software-defined-networking-sdn/', 'https://ieeexplore.ieee.org/document/6634305']",0,12_programming_SDNs,0.9,0.774424843940217
92,Which of the following is the appropriate Pyretic rule for matching traffic that sends packets from either 10.0.0.1 or 10.0.0.2 to IP address 1.2.3.4?,"a. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
b. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
c. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
d. (match(srcip=10.0.0.1) >> (match(srcip=10.0.0.2) >> mod(dstip=1.2.3.4))
e. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
",,c,c,,"In Pyretic, the '+' operator is used to denote the logical OR operation, and the '>>' operator is used to denote the sequence or logical AND operation. To match traffic from either 10.0.0.1 or 10.0.0.2, we use the OR operator. Then, to apply the modification to the destination IP for both matches, we use the sequence operator to apply the 'mod(dstip=1.2.3.4)' action. Therefore, the correct rule that matches packets from either 10.0.0.1 or 10.0.0.2 and modifies the destination IP to 1.2.3.4 is '(match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)'.","['https://www.cs.princeton.edu/courses/archive/fall13/cos597E/assignments/pyretic.pdf', 'https://frenetic-lang.org/pyretic/']",1,12_programming_SDNs,0.95,0.9964019062087963
93,Which of the following is the appropiate Pyretic rule for sending traffic from source IP address 10.0.0.1 to destination IP address 10.1.2.3 and traffic from source IP address 10.0.0.2 to destination IP address 10.2.3.4?,"a. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2)  + mod(dstip=10.2.3.4))
b. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4))
c. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) >>mod(dstip=10.2.3.4))
d. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) + mod(dstip=10.2.3.4))
e. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) & (match(srcip=10.0.0.2)  >> mod(dstip=10.2.3.4))
",,b,b,,"In Pyretic, the 'match' function is used to specify the match conditions for network traffic, and the 'mod' function is used to modify packet fields. The '>>' operator is used to denote the composition of policies, where traffic that matches the first policy is then processed by the second policy. The '+' operator is used to denote the parallel composition of policies, where both policies are applied independently. The correct rule for sending traffic from a specific source IP to a specific destination IP would use a combination of 'match' to filter the traffic by source IP and '>>' to apply the destination IP modification, followed by '+' to combine the two independent rules. Therefore, the correct option is 'b', which correctly composes the match and modification rules for both source-destination pairs and combines them using the '+' operator.","['https://frenetic-lang.github.io/pyretic/', 'https://www.cs.cornell.edu/projects/quicksilver/public_pdfs/Pyretic.pdf']",1,12_programming_SDNs,0.95,0.9937585204625377
94,Which of the following might be examples that would use a dynamic policy in Pyretic? Select all that apply.,"a. Check each new traffic flow against a list of permitted and prohibited source IP addresses that may change over time.
b. Drop all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
c. Assign each new traffic flow to a different destination IP address based on a round-robin load balancing policy across servers.
d. Count all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
e. Forward traffic through the network based on shortest paths routing, re-routing traffic appropriately when links or nodes fail.
",,"a,c,e","a,c,e",,"Dynamic policies in Pyretic are those that can change over time or in response to network conditions. Choice a involves checking against a list that may change, indicating a dynamic policy. Choice c involves load balancing, which is inherently dynamic as it assigns traffic flows to different servers possibly in a round-robin fashion. Choice e involves adapting to network changes such as link or node failures, which is a dynamic response to network conditions. Choices b and d describe static policies that do not change over time or in response to network conditions.","['https://www.cs.cornell.edu/projects/quicksilver/public_pdfs/Pyretic.pdf', 'https://www.cs.princeton.edu/courses/archive/fall13/cos597E/papers/pyretic.pdf']",1,12_programming_SDNs,0.95,0.9999902405279241
