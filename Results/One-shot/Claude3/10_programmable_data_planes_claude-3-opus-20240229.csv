Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
113,"Which are reasonable approaches for designing a fast, scalable, programmable data plane? Select all that apply.","a. Make hardware routers more programmable with custom OpenFlow chips.
b. Make software routers faster by reducing the need to copy packets from the kernel into user space.
c. Send all traffic through software switches running in user space.
d. Make software routers faster by distributing software routers across clusters.
e. Make software routers faster by amortizing packet-processing costs across batches of packets.
",,"a,b,d,e","a,b,d,e",,"a. Custom chips designed for OpenFlow can make hardware routers more programmable while maintaining performance.b. Avoiding the need to copy packets between kernel and user space can significantly speed up software routers. c. Sending all traffic through user-space software switches would likely be too slow for production use.d. Distributing packet processing across a cluster can allow software routers to scale to handle more traffic.e. Amortizing costs by processing batches of packets at a time is another effective optimization for software routers.Therefore, the reasonable approaches are a, b, d, and e. These techniques can help make the data plane fast, scalable and programmable.","['https://www.usenix.org/system/files/conference/nsdi17/nsdi17-firestone.pdf', 'https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Rizzo.pdf', 'https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-panda.pdf']",1,10_programmable_data_planes,0.9,1
114,What are functions that are commonly performed by a programmable data plane? Select all that apply.,"a. Performing deep packet inspection
b. Forwarding
c. Specifying access control policies
d. Shaping traffic
e. Computing routes
",,"a,b,d","a,b,d",,"The data plane in software-defined networking is responsible for forwarding packets and applying policies or actions to the traffic. Based on this:a. Deep packet inspection can be performed in the data plane to examine packet contents for security or traffic management purposes.b. Forwarding packets between ports based on forwarding tables is a core data plane function. c. Specifying access control policies is typically a control plane function that configures the data plane's behavior.d. Traffic shaping to control the rate of traffic is commonly done in the data plane.e. Computing routes is a control plane function to populate forwarding tables used by the data plane.Therefore, the functions commonly performed by a programmable data plane are a (deep packet inspection), b (forwarding), and d (traffic shaping).","['https://www.sdxcentral.com/networking/sdn/definitions/what-is-sdn-data-plane/', 'https://www.splunk.com/en_us/blog/learn/control-plane-vs-data-plane.html']",1,10_programmable_data_planes,0.95,1
115,Which of the following functions might be performed by a Click element? Select all that apply.,"a. Reading a packet from a network device
b. Dropping packets
c. Counting packets
d. Classifying packets into different priority queues
e. Computing shortest paths routes between two routers
",,"a,b,c,d","a,b,c,d",,"a. A Click element can read packets from a network device.b. A Click element can drop packets based on certain criteria.c. A Click element can maintain counters to count packets.d. A Click element can classify packets into different priority queues based on header fields or other criteria.e. Computing shortest path routes is typically not done by a single Click element, but rather by a routing protocol or separate control-plane software. Individual Click elements are usually focused on data-plane packet processing tasks.Therefore, the correct answers are options a, b, c, and d, which are all functions that could be performed by a Click element.","['https://dl.acm.org/doi/pdf/10.1145/383059.383064', 'https://github.com/kohler/click/wiki/Click-programming']",1,10_programmable_data_planes,0.95,1
116,Which of the following are true about programmable data planes in Click? Select all that apply.,"a. Click elements cannot perform common data plane operations such as TTL decrement or checksum computations.
b. Data-plane processing in Click is limited to a fixed set of elements provided by the software.
c. Click elements can be composed to perform complex functions, such as the forwarding at an IP router.
d. Click configuration is a simplified version of Python.
e. Click elements can be composed to perform complex network-wide functions, such as shortest paths or BGP routing.
",,c,c,,"a. This is false. Click elements can perform common data plane operations such as TTL decrement and checksum computations.b. This is false. Click allows users to write their own elements in C++ to extend data-plane functionality as needed.c. This is true. Click elements are modular components that can be composed to create complex packet processing pipelines, such as an IP router's forwarding logic.d. This is false. Click configurations use a domain-specific language, not a simplified version of Python.e. This is false. Click is designed for data plane packet processing on a single node. Network-wide control plane functions like shortest path computation or BGP routing are not the intended use case for Click.Therefore, only option c is correct about programmable data planes in Click.","['https://www.usenix.org/legacy/event/hotos03/tech/full_papers/kohler/kohler_html/', 'https://dl.acm.org/doi/10.1145/3230543.3230551']",1,10_programmable_data_planes,0.95,1
117,Why does a RouteBricks server assign one core per queue?,"a. Having multiple cores accessing the same queue would require each core to perform only one function in the packet processing pipeline, which is inefficient.
b. Having multiple cores accessing the same queue would require locking to prevent concurrent memory accesses, slowing packet forwarding performance.
c. Having multiple cores accessing the same queue might create the possibility that there is a queue that is not served by any cores.
d. Cores have heterogeneous performance, and packets are different sizes, so it makes sense to assign less powerful cores to queues that have smaller packets.
",,b,b,,"The key issue is avoiding contention and locking overhead when multiple cores access the same queue. If multiple cores were assigned to the same queue, they would need to use locks to coordinate access and prevent race conditions. This locking would add significant overhead and slow down packet forwarding performance. By assigning exactly one core per queue, RouteBricks eliminates the need for locking, allowing each core to process packets from its assigned queue(s) independently and in parallel with other cores. This maximizes performance by keeping cores busy and avoiding synchronization overhead.",['https://dl.acm.org/doi/10.1145/1594977.1592592'],1,10_programmable_data_planes,0.95,1
118,What are some tricks commonly employed in software to accelerate packet forwarding? Select all that apply.,"a. Ethernet GRE tunnels
b. Large packet buffers that hold multiple packets that can be read with a single read
c. Forwarding smaller packets before larger packets
d. Avoiding lookups on the software bridge between virtual interfaces and physical interfaces
e. Batch processing
",,"a,b,d,e","b,e",,"The following tricks are commonly used to accelerate packet forwarding in software:b. Using large packet buffers that can hold multiple packets allows them to be read with a single read operation, reducing the overhead of multiple smaller reads.e. Processing packets in batches rather than individually can amortize fixed processing overheads across multiple packets.The other options are not directly related to software acceleration techniques:a. GRE tunnels encapsulate packets but don't inherently accelerate forwarding. c. Prioritizing smaller packets can reduce latency for those packets but doesn't improve overall throughput.d. The software bridge between virtual and physical interfaces is a necessary component but avoiding lookups there is not a common acceleration technique.","['https://www.usenix.org/legacy/event/nsdi09/tech/full_papers/dobrescu/dobrescu.pdf', 'https://dl.acm.org/doi/10.1145/3098822.3098853']",0,10_programmable_data_planes,0.9,1
119,What are some of the problems with current OpenFlow hardware that motivated a custom OpenFlow chip design? Select all that apply.,"a. Current hardware makes it difficult to implement multiple match action stages, and to repurpose TCAM and SRAM across multiple match-action stages.
b. Current hardware cannot forward traffic at line rates.
c. The current OpenFlow protocol depends on the constraints of conventional switching chips.
d. Current hardware cannot support OpenFlow 1.0 match-action primitives.
e. Current hardware is difficult to repurpose in the field.
",,"a,c,e","a,c,e",,"a. Current hardware is often limited in the number of match-action stages it can support and makes it difficult to flexibly allocate TCAM and SRAM resources across stages. A custom chip could address this.b. Conventional switching chips can typically forward traffic at line rate. This is not a key motivation for a custom OpenFlow chip.c. The OpenFlow protocol has evolved to some degree based on the capabilities of conventional switching chips. A custom chip could enable new protocol features and remove some of these constraints.  d. Conventional switching chips can generally support the match-action primitives in OpenFlow 1.0. Supporting more advanced OpenFlow features is a bigger motivation for a custom chip.e. Conventional switching chips have fixed functionality that is difficult to modify after manufacturing. A custom chip could potentially allow its processing pipeline to be reprogrammed in the field.Therefore, the main motivations for a custom OpenFlow chip are the limitations in the number and flexibility of match-action stages, the constraints the hardware places on the protocol, and the difficulty of modifying the functionality of current chips after manufacturing.",['https://yuba.stanford.edu/~nickm/papers/mf_sigcomm_2013.pdf'],1,10_programmable_data_planes,0.9,1
120,"Which of the following are motivations for SwitchBlade, which supports composition of pre-synthesized hardware data plane modules on an FPGA? Select all that apply.","a. Most data plane protocols involve composing only a limited number of data-plane actions.
b. Experimental data planes may need to operate in parallel with production data planes.
c. Programming in Verilog is difficult.
d. FPGAs are lower-cost and consume less power than conventional ASICs or OpenFlow switching chips.
e. Programming in C is difficult.
",,"a,b,c","a,b,c",,"a. This is a key motivation for SwitchBlade. Most data plane protocols can be composed from a small set of common data plane actions.b. SwitchBlade allows experimental and production data planes to run in parallel on the same FPGA hardware, which is useful for incremental deployment.c. Programming FPGAs directly in Verilog is difficult and time-consuming, so SwitchBlade aims to make FPGA programming easier by allowing composition of pre-built modules. d. While FPGAs may have cost and power advantages over some alternatives, this is not a primary motivation mentioned for SwitchBlade.e. The difficulty of programming in C is not relevant to the FPGA-focused SwitchBlade system.Therefore, the correct answers are options a, b, and c, which capture the key motivations for the SwitchBlade FPGA data plane composition system.","['https://www.usenix.org/conference/nsdi21/presentation/sonchack', 'https://dl.acm.org/doi/abs/10.1145/3452296.3472928']",1,10_programmable_data_planes,0.9,1
