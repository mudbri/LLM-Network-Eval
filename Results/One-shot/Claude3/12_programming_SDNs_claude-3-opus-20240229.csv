Question Number,Question Text,Choices,Valid Question?,Correct Answer,LLM Answer,Correct Explanation,LLM Explanation,URLs,Correct?,Topic,LLM Confidence,logprob Confidence
87,Which of the following reasons make programming OpenFlow switches difficult? Select all that apply.,"a. An OpenFlow controller only sees events for packets that the switches do not know how to handle.
b. OpenFlow networks require a single, centralized network controller.
c. Networks often have switches from multiple hardware vendors.
d. OpenFlow switches control switches at a low level of abstraction.
e. Network policies involve many independent tasks that may have conflicting behaviors.
",,"a,d,e","c,e",,"a. This is not a difficulty in programming OpenFlow switches. In fact, it can make programming easier since the controller does not need to handle known flows.b. OpenFlow networks can have multiple controllers for scalability and fault tolerance, so this is not a difficulty.  c. Having switches from multiple vendors can indeed make programming more difficult due to differences in switch capabilities and OpenFlow implementations.d. OpenFlow provides a relatively high-level flow-based abstraction, so low-level control is not a major difficulty. e. Implementing network policies that involve multiple independent tasks with potentially conflicting behaviors can make programming challenging, as the programmer needs to reason about the interactions.Therefore, the correct answers are options c and e, which identify genuine difficulties in programming OpenFlow networks.","['https://www.opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.0.0.pdf', 'https://ieeexplore.ieee.org/document/6739370']",0,12_programming_SDNs,0.9,1
89,"Suppose that a network operator wants to express a policy that drops all traffic except for traffic from a specific IP prefix (i.e., group of IP addresses).  What problems exist with expressing this policy as a set of OpenFlow rules? Select all that apply.","a. Switches have limited room for flow table entries and cannot store rules for all IP addresses in a prefix by default.
b. The controller may see more than the first packet for a flow that it has already installed.
c. If the controller installs the rules in the wrong order, all traffic might be dropped, instead of allowing the permitted traffic.
d. If the operator starts adding more IP addresses that are permitted to send traffic, performance of the switch might suffer as the number of entries in the switch table grows.
e. Flow table entries can only perform exact matches on IP addresses, so installing rules that operate on groups of IP addresses will take many flow-table entries in the switch.
",,"a,b,c,d","a,d,e",,"a. Switches have limited TCAM space for flow tables, so they cannot store a large number of flow entries by default. Expressing a policy with many IP addresses would require many flow entries.b. This is not a problem specific to the given policy. The controller should only see the first packet of each flow in most cases.c. The order of rule installation should not matter for this type of policy. As long as the drop rule has a lower priority than the allow rules, the policy will work as intended.d. As the number of permitted IP addresses grows, the switch will need to store more flow entries, which can degrade performance as the flow table becomes full.e. OpenFlow 1.0 only supports exact matching on IP addresses. To express a rule that matches a group of IP addresses (e.g., a prefix), multiple flow entries would be needed, one for each IP in the group.Therefore, the correct answers are options a, d, and e, which highlight the problems of limited flow table space and the need for many entries to express policies on groups of IPs.","['https://www.cs.princeton.edu/courses/archive/fall13/cos597E/papers/sdnsurvey.pdf', 'https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-firestone_update.pdf']",0,12_programming_SDNs,0.9,1
90,Which of the following have examples of sequential composition? Select all that apply.,"a. Block all port 80 traffic and count the number of packets that are blocked.
b. Load balance traffic based on whether the traffic matches a particular destination IP prefix.
c. Block all traffic except port 80 and count the number of packets that are blocked.
d. Block all traffic except port 80 traffic, and load balance port 80 traffic across three destination IP addresses.
e. Block all traffic except port 80 and count the number of packets that are not blocked.
",,"b,d,e","a,d",,"Sequential composition involves applying multiple operations in sequence. a. This involves two operations in sequence: (1) blocking port 80 traffic, and (2) counting the number of blocked packets.b. This is not sequential composition, as it involves a single operation based on a condition.c. This is not sequential composition. Although it involves an exception, the counting applies only to blocked packets, not a separate sequential step.d. This involves three sequential operations: (1) blocking all non-port 80 traffic, (2) load balancing the allowed port 80 traffic, and (3) distributing that balanced traffic across three destination IPs.e. Similar to (c), this is not truly sequential as the counting is of the unblocked packets, not a separate step.Therefore, only options (a) and (d) represent examples of sequential composition.","['https://www.usenix.org/legacy/event/hotnets12/tech/full_papers/Monsanto.pdf', 'https://www.cs.princeton.edu/~jrex/papers/frenetic13.pdf']",0,12_programming_SDNs,0.9,1
91,Which of the following have examples of parallel composition? Select all that apply.,"a. Perform load balancing on any traffic that arrives from prefix 130.207.0.0/16 or is destined to port 80.
b. Perform MAC learning on all traffic that is not blocked by a firewall rule.
c. Count all port 80 traffic.
d. Block all traffic whose source IP address is contained in a list of blocked IP addresses.
e. Load balance traffic across multiple destination IP addresses and perform routing to the resulting destination IP addresses.
",,"a,c,d","a,b,e",,"Parallel composition refers to applying multiple policies to the same traffic simultaneously. Let's analyze each option:a. This performs load balancing on traffic that matches either of two conditions (source prefix or destination port). The 'or' indicates parallel composition of the two conditions.b. This applies MAC learning to traffic that is not blocked by a firewall. The 'not' implies the firewall rules are applied in parallel with the MAC learning. c. This is a single operation (counting) applied to traffic that matches one condition. It does not involve parallel composition.d. This is a single operation (blocking) applied to traffic that matches one condition. It does not involve parallel composition.e. This performs load balancing and then routing on the resulting traffic. The 'and' indicates these two operations are applied in sequence to the same traffic, which is parallel composition.Therefore, the correct answers are options a, b, and e, which all involve parallel composition of policies or conditions.","['https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Monsanto.pdf', 'https://www.cs.princeton.edu/~jrex/papers/frenetic12.pdf']",0,12_programming_SDNs,0.95,1
92,Which of the following is the appropriate Pyretic rule for matching traffic that sends packets from either 10.0.0.1 or 10.0.0.2 to IP address 1.2.3.4?,"a. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
b. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) + mod(dstip=1.2.3.4)
c. (match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
d. (match(srcip=10.0.0.1) >> (match(srcip=10.0.0.2) >> mod(dstip=1.2.3.4))
e. (match(srcip=10.0.0.1) >> match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)
",,c,c,,"The correct Pyretic rule for matching traffic that sends packets from either 10.0.0.1 or 10.0.0.2 to IP address 1.2.3.4 is:(match(srcip=10.0.0.1) + match(srcip=10.0.0.2)) >> mod(dstip=1.2.3.4)This rule uses the + operator to combine two match predicates, one for each source IP address. The + operator performs a parallel composition, meaning the rule will match if either of the predicates match.The >> operator then performs a sequential composition, modifying the destination IP of packets that matched either of the source IPs to 1.2.3.4.The other options are incorrect:- a and e use >> between the source IP matches, which is incorrect. - b uses + to combine the source IP matches with the destination IP modification, which is not the right operation.- d nests the matches and modification incorrectly.Therefore, c is the only correct Pyretic rule.","['https://www.frenetic-lang.org/pyretic/manual/', 'https://github.com/frenetic-lang/pyretic/blob/master/README.md']",1,12_programming_SDNs,0.95,1
93,Which of the following is the appropiate Pyretic rule for sending traffic from source IP address 10.0.0.1 to destination IP address 10.1.2.3 and traffic from source IP address 10.0.0.2 to destination IP address 10.2.3.4?,"a. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2)  + mod(dstip=10.2.3.4))
b. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4))
c. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) >>mod(dstip=10.2.3.4))
d. (match(srcip=10.0.0.1) + mod(dstip=10.1.2.3)) >> (match(srcip=10.0.0.2) + mod(dstip=10.2.3.4))
e. (match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) & (match(srcip=10.0.0.2)  >> mod(dstip=10.2.3.4))
",,b,b,,"The correct Pyretic rule for sending traffic from source IP 10.0.0.1 to destination IP 10.1.2.3 and from source IP 10.0.0.2 to destination IP 10.2.3.4 is:(match(srcip=10.0.0.1) >> mod(dstip=10.1.2.3)) + (match(srcip=10.0.0.2) >> mod(dstip=10.2.3.4))This uses the sequential composition operator (>>) to first match the source IP, then modify the destination IP for each flow. The parallel composition operator (+) is used to combine the two flow rules.The other options are incorrect:a) Uses + instead of >> between match and mod c) Uses >> to compose the two flow rules instead of +d) Incorrectly composes the match and mod for each flow, and the two flowse) Uses & instead of + to combine the two flows","['https://www.frenetic-lang.org/pyretic/manual/', 'https://www.cs.princeton.edu/~jrex/papers/frenetic13.pdf']",1,12_programming_SDNs,0.95,1
94,Which of the following might be examples that would use a dynamic policy in Pyretic? Select all that apply.,"a. Check each new traffic flow against a list of permitted and prohibited source IP addresses that may change over time.
b. Drop all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
c. Assign each new traffic flow to a different destination IP address based on a round-robin load balancing policy across servers.
d. Count all traffic arriving from source IP addresses in prefix 10.0.0.0/8.
e. Forward traffic through the network based on shortest paths routing, re-routing traffic appropriately when links or nodes fail.
",,"a,c,e","a,c,e",,"a. Checking flows against a dynamically changing list of permitted/prohibited IPs requires a dynamic policy that can adapt as the list changes over time.b. Dropping traffic from a static prefix can be done with a static policy and does not require dynamic updates.c. Load balancing to different destination IPs in a round-robin fashion for each new flow requires a dynamic policy that can assign the next destination IP based on the current round-robin state.d. Counting traffic from a static prefix can be done with a static policy and does not require dynamic updates.e. Routing based on current shortest paths and re-routing when the topology changes due to failures requires a dynamic policy that can adapt the forwarding behavior based on the current network state.Therefore, the examples that would likely use a dynamic policy in Pyretic are a, c, and e.","['https://openflow.stanford.edu/display/ONL/Pyretic+(Python+Framework)', 'https://www.cs.princeton.edu/courses/archive/fall13/cos597E/papers/pyretic-login13.pdf']",1,12_programming_SDNs,0.9,1
